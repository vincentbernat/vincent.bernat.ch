---
title: "Transient prompt with Zsh"
description: |
  After accepting a command, Zsh can simplify the appearance
  of the prompt to save space in the terminal.
uuid: dddc33a0-a013-4dfa-ae20-cbbaa6f9730d
cover: zsh-compact-prompt@2x.jpg
tags:
  - programming-shell
---

[Powerlevel10k][] is a prompt for *Zsh*. It contains some powerful
features, is astoundingly fast, and easy to customize. I am quite
amazed at the skills of its [main author][]. Be sure to also have a
look at [Zsh for Humans][], a complete *Zsh* configuration including
this theme.

One of the nice features of *Powerlevel10k* is **transient prompts**:
past prompts are reduced to a more minimal configuration to save space
by removing unneeded information.

![Demonstration of a transient prompt with Zsh: past prompts use a
more compact form]([[!!images/zsh-compact-prompt@2x.jpg]] "My
implementation of a transient prompt with Zsh. Past prompts are
compact and include the time of the command execution, the hostname,
and the status of the previous command while the complete prompt
contains more information like the current directory and the Git
branch.")

When it comes to configuring my shell, I still prefer writing and
understanding each line going into it. Therefore, I am still building
my *Zsh* configuration [from scratch][]. Here is how I have integrated
the above transient feature into my prompt.

The first step is to configure the appearance of the prompt in its
compact form. Let's assume we have a variable, `$_vbe_prompt_compact`
set to 1 when we want a compact prompt. We use the
following function to define the prompt appearance:

{% raw %}
    ::zsh
    _vbe_prompt () {
        local retval=$?

        # When compact, just time + prompt sign
        if (( $_vbe_prompt_compact )); then
            # Current time (with timezone for remote hosts)
            _vbe_prompt_segment cyan default "%D{%H:%M${SSH_TTY+ %Z}}"
            # Hostname for remote hosts
            [[ $SSH_TTY ]] && \
                _vbe_prompt_segment black magenta "%B%M%b"
            # Status of the last command
            if (( $retval )); then
                _vbe_prompt_segment red default ${PRCH[reta]}
            else
                _vbe_prompt_segment green cyan ${PRCH[ok]}
            fi
            # End of prompt
            _vbe_prompt_end
            return
        fi

        # Regular prompt with many information
        # […]
    }
    setopt prompt_subst
    PS1='$(_vbe_prompt) '
{% endraw %}

Our next step is to redraw the prompt when accepting a command. This
is done by invoking the `reset-prompt` ZLE widget. We have three cases
to consider:

    ::zsh
    # 1. accepting a new command line
    _vbe_reset-prompt-and-accept-line () {
        _vbe_prompt_compact=1
        zle reset-prompt
        zle .accept-line
    }
    zle -N accept-line _vbe_reset-prompt-and-accept-line

    # 2. executing a command from the history
    _vbe_zle-isearch-exit () {
        [[ $KEYS != $'\r' ]] && return
        _vbe_prompt_compact=1
        zle reset-prompt
    }
    zle -N zle-isearch-exit _vbe_zle-isearch-exit

    # 3. exiting the current shell
    _vbe_reset-prompt-and-exit () {
        _vbe_prompt_compact=1
        zle reset-prompt
        exit
    }
    setopt ignoreeof
    zle -N _vbe_reset-prompt-and-exit
    bindkey '^D' _vbe_reset-prompt-and-exit
    TRAPINT() {
        zle && [[ $#zsh_eval_context == 1 ]] && {
            _vbe_prompt_compact=1
            zle reset-prompt
        }
        return $((128+$1))
    }

And before executing the command line, we need to unset the
`$_vbe_prompt_compact` variable to ensure the next prompt is drawn
using the regular form:

    ::zsh
    # Just before executing the command for real,
    # signal the next prompt should be a regular one.
    _vbe_prompt_precmd () {
        unset _vbe_prompt_compact
    }
    add-zsh-hook precmd _vbe_prompt_precmd

That's all!

---

One downside of using the powerline fonts is that it messes with
copy/paste. As I am using *tmux*, I use the following snippet to work
around this issue and use only standard Unicode characters when
copying from the terminal:

    bind-key -T copy-mode M-w \
      send -X copy-pipe-and-cancel "sed 's/.*/%/g' | xclip -i -selection clipboard" \;\
      display-message "Selection saved to clipboard!"

Copying and pasting the text from the screenshot above yields the
following text:

    ::console
    14:21 % ssh eizo.luffy.cx
    Linux eizo 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64
    Last login: Fri Apr 23 14:20:39 2021 from 2a01:cb00:3f:b02:9db6:efa4:d85:7f9f
    14:21 CEST % uname -a
    Linux eizo 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64 GNU/Linux
    14:21 CEST %
    Connection to eizo.luffy.cx closed.
    14:22 % git status
    On branch article/zsh-transient
    Untracked files:
      (use "git add <file>..." to include in what will be committed)
            ../../media/images/zsh-compact-prompt@2x.jpg

    nothing added to commit but untracked files present (use "git add" to track)

[Powerlevel10k]: https://github.com/romkatv/powerlevel10k
[Zsh for Humans]: https://github.com/romkatv/zsh4humans
[main author]: https://github.com/romkatv "Roman Perepelitsa"
[from scratch]: [[en/blog/2011-zsh-zshrc.html]] "Rewriting my .zshrc"
