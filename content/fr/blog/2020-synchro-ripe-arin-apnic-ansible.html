---
title: "Synchroniser des objets RIPE, ARIN et APNIC avec un module Ansible sur mesure"
description: |
 Cet article d√©crit un module Ansible permettant de synchroniser
 les objets RIPE, ARIN et APNIC.
uuid: 8e95d250-a7b1-4a79-b5e1-4d45643c8062
attachments:
  "https://github.com/vincentbernat/ansible-custom-module-examples/blob/main/irr_sync.py": Code du module
tags:
  - network-automation
  - programming-python
---

L'Internet est divis√© en cinq [registres Internet r√©gionaux][regional
Internet registry] : AFRINIC, ARIN, APNIC, LACNIC et RIPE. Chacun de
ces RIR g√®re un [registre de routage Internet][Internet Routing
Registry]. Un tel IRR permet de publier des **informations sur le
routage des ressources Internet**[^others]. Les op√©rateurs l'utilisent
pour d√©terminer le propri√©taire d'une adresse IP et pour construire et
maintenir des **filtres de routage**. Pour que vos routes soient
largement accept√©es, il est important de tenir √† jour les pr√©fixes que
vous annoncez dans un IRR.

[^others]: D'autres IRR existent en dehors de ceux maintenus par les
    RIR. Le plus connu est [RADb][].

Il existe deux outils courants pour interroger cette base de donn√©es :
`whois` et `bgpq4`. Le premier vous permet d'effectuer une requ√™te
avec le [protocole WHOIS][WHOIS protocol] :

    ::console
    $ whois -h whois.ripe.net -- '-BrG 2a0a:e805:400::/40'
    [‚Ä¶]
    inet6num:       2a0a:e805:400::/40
    netname:        FR-BLADE-CUSTOMERS-DE
    country:        DE
    geoloc:         50.1109 8.6821
    admin-c:        BN2763-RIPE
    tech-c:         BN2763-RIPE
    status:         ASSIGNED
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2020-05-19T08:04:58Z
    last-modified:  2020-05-19T08:04:58Z
    source:         RIPE
    
    route6:         2a0a:e805:400::/40
    descr:          Blade IPv6 - AMS1
    origin:         AS64476
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2019-10-01T08:19:34Z
    last-modified:  2020-05-19T08:05:00Z
    source:         RIPE

Le second permet de construire des filtres de routage en utilisant les
informations contenues dans la base de donn√©es IRR :

    ::console
    $ bgpq4 -6 -S RIPE -b AS64476
    NN = [
        2a0a:e805::/40,
        2a0a:e805:100::/40,
        2a0a:e805:300::/40,
        2a0a:e805:400::/40,
        2a0a:e805:500::/40
    ];

Il n'y a pas de module disponible sur [Ansible Galaxy][] pour g√©rer
ces objets. Chaque IRR a diff√©rentes fa√ßons d'√™tre mis √† jour.
Certains RIR proposent une API, mais d'autres non. Si l'on se limite
au RIPE, √† l'ARIN et √† l'APNIC, la seule m√©thode commune de mise √†
jour des objets est la [mise √† jour par courrier √©lectronique][email
updates], authentifi√© par un mot de passe ou une signature PGP[^support].
√âcrivons un module Ansible √† cet effet !

[^support]: L'ARIN abandonne progressivement cette m√©thode au profit de
    [IRR-online][]. De plus, les signatures PGP n'ont jamais √©t√©
    support√©es en dehors de l'environnement de test. RIPE dispose
    d'une [API][REST API], mais les mises √† jour par courrier
    √©lectronique sont toujours prises en charge et il n'est pas pr√©vu
    de les faire dispara√Ætre. L'APNIC pr√©voit d'exposer une
    [API][APNIC API].

!!! "Note" Je vous recommande de lire ¬´¬†[√âcrire un module Ansible sur
mesure][]¬†¬ª en introduction, ainsi que ¬´¬†[Synchroniser des tables
MySQL][]¬†¬ª pour un premier exemple plus didactique.

# Code

Le [module][] prend une liste d'objets RPSL √† synchroniser et renvoie
le contenu d'un courrier √©lectronique pour mise √† jour si un changement
est n√©cessaire :

    ::yaml
    - name: prepare RIPE objects
      irr_sync:
        irr: RIPE
        mntner: fr-blade-1-mnt
        source: whois-ripe.txt
      register: irr

## Pr√©requis

Le fichier source doit √™tre un ensemble d'objets √† synchroniser en
utilisant le [langage RPSL][RPSL language]. Il s'agirait du m√™me
contenu que celui que vous enverriez manuellement par courrier
√©lectronique. Tous les objets doivent √™tre g√©r√©s par le m√™me
mainteneur, √©galement fourni en param√®tre.

La signature[^arin] et l'envoi du r√©sultat ne rel√®vent pas de la
responsabilit√© de ce module. Vous avez besoin de deux t√¢ches
suppl√©mentaires √† cette fin :

    ::yaml hl_lines="4 5 18"
    - name: sign RIPE objects
      shell:
        cmd: gpg --batch --local-user noc@example.com --clearsign
        stdin: "{% raw %}{{ irr.objects }}{% endraw %}"
      register: signed
      check_mode: false
      changed_when: false
    
    - name: update RIPE objects by email
      mail:
        subject: "NEW: update for RIPE"
        from: noc@example.com
        to: "auto-dbm@ripe.net"
        cc: noc@example.com
        host: smtp.example.com
        port: 25
        charset: us-ascii
        body: "{% raw %}{{ signed.stdout }}{% endraw %}"

[^arin]: PGP n'est pas pris en charge par l'ARIN en dehors de
    l'environnement de test. Seule l'authentification par mot de passe
    est disponible... üòï

Vous devez aussi autoriser la clef PGP utilis√©e pour signer les mises
√† jour en cr√©ant un objet `key-cert` et en l'ajoutant comme m√©thode
d'authentification pour l'objet `mntner` correspondant :

    ::yaml
    key-cert:  PGPKEY-A791AAAB
    certif:    -----BEGIN PGP PUBLIC KEY BLOCK-----
    certif:    
    certif:    mQGNBF8TLY8BDADEwP3a6/vRhEERBIaPUAFnr23zKCNt5YhWRZyt50mKq1RmQBBY
    [‚Ä¶]
    certif:    -----END PGP PUBLIC KEY BLOCK-----
    mnt-by:    fr-blade-1-mnt
    source:    RIPE
    
    mntner:    fr-blade-1-mnt
    [‚Ä¶]
    auth:      PGPKEY-A791AAAB
    mnt-by:    fr-blade-1-mnt
    source:    RIPE

## D√©finition du module

En se basant sur le squelette pr√©sent√© dans l'[article
pr√©c√©dent][√âcrire un module ansible sur mesure], nous d√©finissons le
module :

    ::python
    module_args = dict(
        irr=dict(type='str', required=True),
        mntner=dict(type='str', required=True),
        source=dict(type='path', required=True),
    )

    result = dict(
        changed=False,
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

## Obtenir les objets existants

Pour r√©cup√©rer les objets existants, la commande `whois` recherche
tous les objets attach√©s au mainteneur fourni en param√®tre du module.

    ::python
    # Per-IRR variations:
    # - whois server
    whois = {
        'ARIN': 'rr.arin.net',
        'RIPE': 'whois.ripe.net',
        'APNIC': 'whois.apnic.net'
    }
    # - whois options
    options = {
        'ARIN': ['-r'],
        'RIPE': ['-BrG'],
        'APNIC': ['-BrG']
    }
    # - objects excluded from synchronization
    excluded = ["domain"]
    if irr == "ARIN":
        # ARIN does not return these objects
        excluded.extend([
            "key-cert",
            "mntner",
        ])

    # Grab existing objects
    args = ["-h", whois[irr],
            "-s", irr,
            *options[irr],
            "-i", "mnt-by",
            module.params['mntner']]
    proc = subprocess.run(["whois", *args], capture_output=True)
    if proc.returncode != 0:
        raise AnsibleError(
            f"unable to query whois: {args}")
    output = proc.stdout.decode('ascii')
    got = extract(output, excluded)

La premi√®re partie du code introduit des constantes sp√©cifiques √†
chaque IRR : le serveur √† interroger, les options √† fournir √† la
commande `whois` et les objets √† exclure de la synchronisation. La
seconde partie invoque la commande `whois` qui r√©cup√®re tous les
objets dont le champ `mnt-by` correspond au mainteneur fourni. Voici
un exemple de sortie :

    ::console
    $ whois -h whois.ripe.net -- '-s RIPE -BrG -i mnt-by fr-blade-1-mnt'
    [‚Ä¶]
    
    inet6num:       2a0a:e805:300::/40
    netname:        FR-BLADE-CUSTOMERS-FR
    country:        FR
    geoloc:         48.8566 2.3522
    admin-c:        BN2763-RIPE
    tech-c:         BN2763-RIPE
    status:         ASSIGNED
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2020-05-19T08:04:59Z
    last-modified:  2020-05-19T08:04:59Z
    source:         RIPE
    
    [‚Ä¶]
    
    route6:         2a0a:e805:300::/40
    descr:          Blade IPv6 - PA1
    origin:         AS64476
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2019-10-01T08:19:34Z
    last-modified:  2020-05-19T08:05:00Z
    source:         RIPE
    
    [‚Ä¶]

Le r√©sultat est transmis √† la fonction `extract()`. Elle analyse et
normalise les r√©sultats dans un dictionnaire qui met en correspondance
les noms d'objets et les objets. Nous stockons le r√©sultat dans la
variable `got`.

    ::python
    def extract(raw, excluded):
        """Extract objects."""
        # First step, remove comments and unwanted lines
        objects = "\n".join([obj
                             for obj in raw.split("\n")
                             if not obj.startswith((
                                     "#",
                                     "%",
                             ))])
        # Second step, split objects
        objects = [RPSLObject(obj.strip())
                   for obj in re.split(r"\n\n+", objects)
                   if obj.strip()
                   and not obj.startswith(
                       tuple(f"{x}:" for x in excluded))]
        # Last step, put objects in a dict
        objects = {repr(obj): obj
                   for obj in objects}
        return objects

`RPSLObject()` est la classe qui permet de normaliser et comparer les
objets. Regardez le [code du module][module] pour plus de d√©tails.

    ::pycon
    >>> output="""
    ... inet6num:       2a0a:e805:300::/40
    ... [‚Ä¶]
    ... """
    >>> pprint({k: str(v) for k,v in extract(output, excluded=[])})
    {'<Object:inet6num:2a0a:e805:300::/40>':
       'inet6num:       2a0a:e805:300::/40\n'
       'netname:        FR-BLADE-CUSTOMERS-FR\n'
       'country:        FR\n'
       'geoloc:         48.8566 2.3522\n'
       'admin-c:        BN2763-RIPE\n'
       'tech-c:         BN2763-RIPE\n'
       'status:         ASSIGNED\n'
       'mnt-by:         fr-blade-1-mnt\n'
       'remarks:        synced with cmdb\n'
       'source:         RIPE',
     '<Object:route6:2a0a:e805:300::/40>':
       'route6:         2a0a:e805:300::/40\n'
       'descr:          Blade IPv6 - PA1\n'
       'origin:         AS64476\n'
       'mnt-by:         fr-blade-1-mnt\n'
       'remarks:        synced with cmdb\n'
       'source:         RIPE'}

## Comparer avec les objets souhait√©s

Construisons maintenant le dictionnaire `wanted` en r√©utilisant la
fonction `extract()` :

    ::python
    with open(module.params['source']) as f:
        source = f.read()
    wanted = extract(source, excluded)

L'√©tape suivante est de comparer `got` et `wanted` pour construire les
diff√©rences :

    ::python
    if got != wanted:
        result['changed'] = True
        if module._diff:
            result['diff'] = [
                dict(before_header=k,
                     after_header=k,
                     before=str(got.get(k, "")),
                     after=str(wanted.get(k, "")))
                for k in set((*wanted.keys(), *got.keys()))
                if k not in wanted or k not in got or wanted[k] != got[k]]

## Retourner les mises √† jour

Le module n'a pas d'effet de bord. S'il y a une diff√©rence, nous
retournons les mises √† jour √† envoyer par courrier √©lectronique. Nous
choisissons d'inclure tous les objets souhait√©s dans les mises √† jour
(contenus dans la variable `source`) et de laisser l'IRR ignorer les
objets non modifi√©s. Nous ajoutons √©galement les objets √† supprimer en
ajoutant un attribut `delete:` √† chacun d'entre eux.

    ::python
    # We send all source objects and deleted objects.
    deleted_mark = f"{'delete:':16}deleted by CMDB"
    deleted = "\n\n".join([f"{got[k].raw}\n{deleted_mark}"
                           for k in got
                           if k not in wanted])
    result['objects'] = f"{source}\n\n{deleted}"
    
    module.exit_json(**result)

---

Le code complet est disponible sur [GitHub][module]. Le module prend
en charge les options `--diff` et `--check`. Il ne renvoie rien si
aucun changement n'est d√©tect√©. Il peut fonctionner avec l'APNIC, le
RIPE et l'ARIN. Il n'est pas parfait : il peut ne pas d√©tecter
certains changements[^changes], il n'est pas capable de modifier des
objets n'appartenant pas au mainteneur fourni[^mntner] et certains
attributs refusent les mises √† jour, ce qui n√©cessite de supprimer et
de recr√©er manuellement l'objet[^modify]. Cependant, ce module devrait
automatiser 95% de vos besoins.

[^changes]: Pour l'ARIN, nous ne pouvons pas interroger les objets
    `key-cert` et `mntner` et donc nous ne pouvons pas d√©tecter les
    changements qui s'y produisent. Il n'est pas non plus possible de
    d√©tecter les modifications des m√©canismes d'authentification d'un
    objet `mntner`.


[^mntner]: L'APNIC n'attribue pas les objets de plus haut niveau au
    mainteneur associ√© au propri√©taire.

[^modify]: Pour modifier le statut d'un objet `inetnum`, il faut
    supprimer et recr√©er l'objet.

*[RIR]: Regional Internet Registry
*[IRR]: Internet Routing Registry
*[AFRINIC]: African Network Information Center
*[ARIN]: American Registry for Internet Numbers
*[APNIC]: Asia-Pacific Network Information Centre
*[RIPE]: R√©seaux IP Europ√©ens Network Coordination Centre
*[LACNIC]: Latin America and Caribbean Network Information Centre
*[RPSL]: Routing Policy Specification Language

[Ansible Galaxy]: https://galaxy.ansible.com "Ansible Galaxy"
[√âcrire un module Ansible sur mesure]: [[fr/blog/2020-ecrire-module-ansible.html]] "√âcrire un module Ansible sur mesure"
[Synchroniser des tables MySQL]: [[fr/blog/2020-synchro-tables-mysql-ansible.html]] "Synchroniser des tables MySQL avec un module Ansible sur mesure"
[module]: https://github.com/vincentbernat/ansible-custom-module-examples/blob/main/irr_sync.py
[regional Internet registry]: https://en.wikipedia.org/wiki/Regional_Internet_registry "Regional Internet registry on Wikipedia"
[Internet Routing Registry]: https://en.wikipedia.org/wiki/Internet_Routing_Registry "Internet Routing Registry on Wikipedia"
[WHOIS protocol]: https://tools.ietf.org/html/rfc3912 "RFC 3912: WHOIS Protocol Specification"
[REST API]: https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/updating-objects-in-the-ripe-database/6-1-restful-api "RIPE Database RESTful API"
[email updates]: https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/updating-objects-in-the-ripe-database/6-4-email-updates "RIPE NCC: Email Updates"
[IRR-online]: https://www.arin.net/resources/manage/irr/irr-online-implementation/#using-the-web-based-interface-irr-online "ARIN: Using the Web-Based Interface (IRR-online)"
[APNIC API]: https://www.apnic.net/manage-ip/apnic-services/services-roadmap/public-api-draft-for-members/ "APNIC: Public API Draft (for Members)"
[RPSL language]: https://tools.ietf.org/html/rfc2622 "RFC 2622: Routing Policy Specification Language (RPSL)"
[RADb]: https://www.radb.net/ "RADb"
