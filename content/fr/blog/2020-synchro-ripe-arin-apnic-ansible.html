---
title: "Synchroniser des objets RIPE, ARIN et APNIC avec un module Ansible sur mesure"
description: |
 Cet article dÃ©crit un module Ansible permettant de synchroniser
 les objets RIPE, ARIN et APNIC.
uuid: 8e95d250-a7b1-4a79-b5e1-4d45643c8062
attachments:
  "https://github.com/vincentbernat/ansible-custom-module-examples/blob/main/irr_sync.py": Code du module
tags:
  - network-automation
  - programming-python
---

L'Internet est divisÃ© en cinq [registres Internet rÃ©gionaux][regional
Internet registry] : AFRINIC, ARIN, APNIC, LACNIC et RIPE. Chacun de
ces RIR gÃ¨re un [registre de routage Internet][Internet Routing
Registry]. Un tel IRR permet de publier des **informations sur le
routage des ressources Internet**[^others]. Les opÃ©rateurs l'utilisent
pour dÃ©terminer le propriÃ©taire d'une adresse IP et pour construire et
maintenir des **filtres de routage**. Pour que vos routes soient
largement acceptÃ©es, il est important de tenir Ã  jour les prÃ©fixes que
vous annoncez dans un IRR.

[^others]: D'autres IRR existent en dehors de ceux maintenus par les
    RIR. Le plus connu est [RADb][].

Il existe deux outils courants pour interroger cette base de donnÃ©es :
`whois` et `bgpq4`. Le premier vous permet d'effectuer une requÃªte
avec le [protocole WHOIS][WHOIS protocol] :

    ::console
    $ whois -h whois.ripe.net -- '-BrG 2a0a:e805:400::/40'
    [â€¦]
    inet6num:       2a0a:e805:400::/40
    netname:        FR-BLADE-CUSTOMERS-DE
    country:        DE
    geoloc:         50.1109 8.6821
    admin-c:        BN2763-RIPE
    tech-c:         BN2763-RIPE
    status:         ASSIGNED
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2020-05-19T08:04:58Z
    last-modified:  2020-05-19T08:04:58Z
    source:         RIPE
    
    route6:         2a0a:e805:400::/40
    descr:          Blade IPv6 - AMS1
    origin:         AS64476
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2019-10-01T08:19:34Z
    last-modified:  2020-05-19T08:05:00Z
    source:         RIPE

Le second permet de construire des filtres de routage en utilisant les
informations contenues dans la base de donnÃ©es IRR :

    ::console
    $ bgpq4 -6 -S RIPE -b AS64476
    NN = [
        2a0a:e805::/40,
        2a0a:e805:100::/40,
        2a0a:e805:300::/40,
        2a0a:e805:400::/40,
        2a0a:e805:500::/40
    ];

Il n'y a pas de module disponible sur [Ansible Galaxy][] pour gÃ©rer
ces objets. Chaque IRR a diffÃ©rentes faÃ§ons d'Ãªtre mis Ã  jour.
Certains RIR proposent une API, mais d'autres non. Si l'on se limite
au RIPE, Ã  l'ARIN et Ã  l'APNIC, la seule mÃ©thode commune de mise Ã 
jour des objets est la [mise Ã  jour par courrier Ã©lectronique][email
updates], authentifiÃ© par un mot de passe ou une signature PGP[^support].
Ã‰crivons un module Ansible Ã  cet effet !

[^support]: L'ARIN abandonne progressivement cette mÃ©thode au profit de
    [IRR-online][]. De plus, les signatures PGP n'ont jamais Ã©tÃ©
    supportÃ©es en dehors de l'environnement de test. RIPE dispose
    d'une [API][REST API], mais les mises Ã  jour par courrier
    Ã©lectronique sont toujours prises en charge et il n'est pas prÃ©vu
    de les faire disparaÃ®tre. L'APNIC prÃ©voit d'exposer une
    [API][APNIC API].

!!! "Note" Je vous recommande de lire Â«Â [Ã‰crire un module Ansible sur
mesure][]Â Â» en introduction, ainsi que Â«Â [Synchroniser des tables
MySQL][]Â Â» pour un premier exemple plus didactique.

# Code

Le [module][] prend une liste d'objets RPSL Ã  synchroniser et renvoie
le contenu d'un courrier Ã©lectronique pour mise Ã  jour si un changement
est nÃ©cessaire :

    ::yaml
    - name: prepare RIPE objects
      irr_sync:
        irr: RIPE
        mntner: fr-blade-1-mnt
        source: whois-ripe.txt
      register: irr

## PrÃ©requis

Le fichier source doit Ãªtre un ensemble d'objets Ã  synchroniser en
utilisant le [langage RPSL][RPSL language]. Il s'agirait du mÃªme
contenu que celui que vous enverriez manuellement par courrier
Ã©lectronique. Tous les objets doivent Ãªtre gÃ©rÃ©s par le mÃªme
mainteneur, Ã©galement fourni en paramÃ¨tre.

La signature[^arin] et l'envoi du rÃ©sultat ne relÃ¨vent pas de la
responsabilitÃ© de ce module. Vous avez besoin de deux tÃ¢ches
supplÃ©mentaires Ã  cette fin :

    ::yaml hl_lines="4 5 18"
    - name: sign RIPE objects
      shell:
        cmd: gpg --batch --local-user noc@example.com --clearsign
        stdin: "{% raw %}{{ irr.objects }}{% endraw %}"
      register: signed
      check_mode: false
      changed_when: false
    
    - name: update RIPE objects by email
      mail:
        subject: "NEW: update for RIPE"
        from: noc@example.com
        to: "auto-dbm@ripe.net"
        cc: noc@example.com
        host: smtp.example.com
        port: 25
        charset: us-ascii
        body: "{% raw %}{{ signed.stdout }}{% endraw %}"

[^arin]: PGP n'est pas pris en charge par l'ARIN en dehors de
    l'environnement de test. Seule l'authentification par mot de passe
    est disponible... ðŸ˜•

Vous devez aussi autoriser la clef PGP utilisÃ©e pour signer les mises
Ã  jour en crÃ©ant un objet `key-cert` et en l'ajoutant comme mÃ©thode
d'authentification pour l'objet `mntner` correspondant :

    ::yaml
    key-cert:  PGPKEY-A791AAAB
    certif:    -----BEGIN PGP PUBLIC KEY BLOCK-----
    certif:    
    certif:    mQGNBF8TLY8BDADEwP3a6/vRhEERBIaPUAFnr23zKCNt5YhWRZyt50mKq1RmQBBY
    [â€¦]
    certif:    -----END PGP PUBLIC KEY BLOCK-----
    mnt-by:    fr-blade-1-mnt
    source:    RIPE
    
    mntner:    fr-blade-1-mnt
    [â€¦]
    auth:      PGPKEY-A791AAAB
    mnt-by:    fr-blade-1-mnt
    source:    RIPE

## DÃ©finition du module

En se basant sur le squelette prÃ©sentÃ© dans l'[article
prÃ©cÃ©dent][Ã‰crire un module ansible sur mesure], nous dÃ©finissons le
module :

    ::python
    module_args = dict(
        irr=dict(type='str', required=True),
        mntner=dict(type='str', required=True),
        source=dict(type='path', required=True),
    )

    result = dict(
        changed=False,
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

## Obtenir les objets existants

Pour rÃ©cupÃ©rer les objets existants, la commande `whois` recherche
tous les objets attachÃ©s au mainteneur fourni en paramÃ¨tre du module.

    ::python
    # Per-IRR variations:
    # - whois server
    whois = {
        'ARIN': 'rr.arin.net',
        'RIPE': 'whois.ripe.net',
        'APNIC': 'whois.apnic.net'
    }
    # - whois options
    options = {
        'ARIN': ['-r'],
        'RIPE': ['-BrG'],
        'APNIC': ['-BrG']
    }
    # - objects excluded from synchronization
    excluded = ["domain"]
    if irr == "ARIN":
        # ARIN does not return these objects
        excluded.extend([
            "key-cert",
            "mntner",
        ])

    # Grab existing objects
    args = ["-h", whois[irr],
            "-s", irr,
            *options[irr],
            "-i", "mnt-by",
            module.params['mntner']]
    proc = subprocess.run(["whois", *args], capture_output=True)
    if proc.returncode != 0:
        raise AnsibleError(
            f"unable to query whois: {args}")
    output = proc.stdout.decode('ascii')
    got = extract(output, excluded)

La premiÃ¨re partie du code introduit des constantes spÃ©cifiques Ã 
chaque IRR : le serveur Ã  interroger, les options Ã  fournir Ã  la
commande `whois` et les objets Ã  exclure de la synchronisation. La
seconde partie invoque la commande `whois` qui rÃ©cupÃ¨re tous les
objets dont le champ `mnt-by` correspond au mainteneur fourni. Voici
un exemple de sortie :

    ::console
    $ whois -h whois.ripe.net -- '-s RIPE -BrG -i mnt-by fr-blade-1-mnt'
    [â€¦]
    
    inet6num:       2a0a:e805:300::/40
    netname:        FR-BLADE-CUSTOMERS-FR
    country:        FR
    geoloc:         48.8566 2.3522
    admin-c:        BN2763-RIPE
    tech-c:         BN2763-RIPE
    status:         ASSIGNED
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2020-05-19T08:04:59Z
    last-modified:  2020-05-19T08:04:59Z
    source:         RIPE
    
    [â€¦]
    
    route6:         2a0a:e805:300::/40
    descr:          Blade IPv6 - PA1
    origin:         AS64476
    mnt-by:         fr-blade-1-mnt
    remarks:        synced with cmdb
    created:        2019-10-01T08:19:34Z
    last-modified:  2020-05-19T08:05:00Z
    source:         RIPE
    
    [â€¦]

Le rÃ©sultat est transmis Ã  la fonction `extract()`. Elle analyse et
normalise les rÃ©sultats dans un dictionnaire qui met en correspondance
les noms d'objets et les objets. Nous stockons le rÃ©sultat dans la
variable `got`.

    ::python
    def extract(raw, excluded):
        """Extract objects."""
        # First step, remove comments and unwanted lines
        objects = "\n".join([obj
                             for obj in raw.split("\n")
                             if not obj.startswith((
                                     "#",
                                     "%",
                             ))])
        # Second step, split objects
        objects = [RPSLObject(obj.strip())
                   for obj in re.split(r"\n\n+", objects)
                   if obj.strip()
                   and not obj.startswith(
                       tuple(f"{x}:" for x in excluded))]
        # Last step, put objects in a dict
        objects = {repr(obj): obj
                   for obj in objects}
        return objects

`RPSLObject()` est la classe qui permet de normaliser et comparer les
objets. Regardez le [code du module][module] pour plus de dÃ©tails.

    ::pycon
    >>> output="""
    ... inet6num:       2a0a:e805:300::/40
    ... [â€¦]
    ... """
    >>> pprint({k: str(v) for k,v in extract(output, excluded=[])})
    {'<Object:inet6num:2a0a:e805:300::/40>':
       'inet6num:       2a0a:e805:300::/40\n'
       'netname:        FR-BLADE-CUSTOMERS-FR\n'
       'country:        FR\n'
       'geoloc:         48.8566 2.3522\n'
       'admin-c:        BN2763-RIPE\n'
       'tech-c:         BN2763-RIPE\n'
       'status:         ASSIGNED\n'
       'mnt-by:         fr-blade-1-mnt\n'
       'remarks:        synced with cmdb\n'
       'source:         RIPE',
     '<Object:route6:2a0a:e805:300::/40>':
       'route6:         2a0a:e805:300::/40\n'
       'descr:          Blade IPv6 - PA1\n'
       'origin:         AS64476\n'
       'mnt-by:         fr-blade-1-mnt\n'
       'remarks:        synced with cmdb\n'
       'source:         RIPE'}

## Comparer avec les objets souhaitÃ©s

Construisons maintenant le dictionnaire `wanted` en rÃ©utilisant la
fonction `extract()` :

    ::python
    with open(module.params['source']) as f:
        source = f.read()
    wanted = extract(source, excluded)

L'Ã©tape suivante est de comparer `got` et `wanted` pour construire les
diffÃ©rences :

    ::python
    if got != wanted:
        result['changed'] = True
        if module._diff:
            result['diff'] = [
                dict(before_header=k,
                     after_header=k,
                     before=str(got.get(k, "")),
                     after=str(wanted.get(k, "")))
                for k in set((*wanted.keys(), *got.keys()))
                if k not in wanted or k not in got or wanted[k] != got[k]]

## Retourner les mises Ã  jour

Le module n'a pas d'effet de bord. S'il y a une diffÃ©rence, nous
retournons les mises Ã  jour Ã  envoyer par courrier Ã©lectronique. Nous
choisissons d'inclure tous les objets souhaitÃ©s dans les mises Ã  jour
(contenus dans la variable `source`) et de laisser l'IRR ignorer les
objets non modifiÃ©s. Nous ajoutons Ã©galement les objets Ã  supprimer en
ajoutant un attribut `delete:` Ã  chacun d'entre eux.

    ::python
    # We send all source objects and deleted objects.
    deleted_mark = f"{'delete:':16}deleted by CMDB"
    deleted = "\n\n".join([f"{got[k].raw}\n{deleted_mark}"
                           for k in got
                           if k not in wanted])
    result['objects'] = f"{source}\n\n{deleted}"
    
    module.exit_json(**result)

---

Le code complet est disponible sur [GitHub][module]. Le module prend
en charge les options `--diff` et `--check`. Il ne renvoie rien si
aucun changement n'est dÃ©tectÃ©. Il peut fonctionner avec l'APNIC, le
RIPE et l'ARIN. Il n'est pas parfait : il peut ne pas dÃ©tecter
certains changements[^changes], il n'est pas capable de modifier des
objets n'appartenant pas au mainteneur fourni[^mntner] et certains
attributs refusent les mises Ã  jour, ce qui nÃ©cessite de supprimer et
de recrÃ©er manuellement l'objet[^modify]. Cependant, ce module devrait
automatiser 95% de vos besoins.

[^changes]: Pour l'ARIN, nous ne pouvons pas interroger les objets
    `key-cert` et `mntner` et donc nous ne pouvons pas dÃ©tecter les
    changements qui s'y produisent. Il n'est pas non plus possible de
    dÃ©tecter les modifications des mÃ©canismes d'authentification d'un
    objet `mntner`.


[^mntner]: L'APNIC n'attribue pas les objets de plus haut niveau au
    mainteneur associÃ© au propriÃ©taire.

[^modify]: Pour modifier le statut d'un objet `inetnum`, il faut
    supprimer et recrÃ©er l'objet.

*[RIR]: Regional Internet Registry
*[IRR]: Internet Routing Registry
*[AFRINIC]: African Network Information Center
*[ARIN]: American Registry for Internet Numbers
*[APNIC]: Asia-Pacific Network Information Centre
*[RIPE]: RÃ©seaux IP EuropÃ©ens Network Coordination Centre
*[LACNIC]: Latin America and Caribbean Network Information Centre
*[RPSL]: Routing Policy Specification Language

[Ansible Galaxy]: https://galaxy.ansible.com "Ansible Galaxy"
[Ã‰crire un module Ansible sur mesure]: [[fr/blog/2020-ecrire-module-ansible.html]] "Ã‰crire un module Ansible sur mesure"
[Synchroniser des tables MySQL]: [[fr/blog/2020-synchro-tables-mysql-ansible.html]] "Synchroniser des tables MySQL avec un module Ansible sur mesure"
[module]: https://github.com/vincentbernat/ansible-custom-module-examples/blob/main/irr_sync.py
[regional Internet registry]: https://en.wikipedia.org/wiki/Regional_Internet_registry "Regional Internet registry on Wikipedia"
[Internet Routing Registry]: https://en.wikipedia.org/wiki/Internet_Routing_Registry "Internet Routing Registry on Wikipedia"
[WHOIS protocol]: https://tools.ietf.org/html/rfc3912 "RFC 3912: WHOIS Protocol Specification"
[REST API]: https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/updating-objects-in-the-ripe-database/6-1-restful-api "RIPE Database RESTful API"
[email updates]: https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/updating-objects-in-the-ripe-database/6-4-email-updates "RIPE NCC: Email Updates"
[IRR-online]: https://www.arin.net/resources/manage/irr/irr-online-implementation/#using-the-web-based-interface-irr-online "ARIN: Using the Web-Based Interface (IRR-online)"
[APNIC API]: https://www.apnic.net/manage-ip/apnic-services/services-roadmap/public-api-draft-for-members/ "APNIC: Public API Draft (for Members)"
[RPSL language]: https://tools.ietf.org/html/rfc2622 "RFC 2622: Routing Policy Specification Language (RPSL)"
[RADb]: https://www.radb.net/ "RADb"
