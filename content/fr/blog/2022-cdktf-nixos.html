---
title: G√©rer une infrastructure avec Terraform, CDKTF et NixOS
description: |
  Comment j'utilise CDKTF, Terraform, Nix et NixOS pour g√©rer mon infrastructure
  personnelle.
uuid: a8682289-f1ec-4f54-ac54-839d2dc46417
attachments:
  "https://github.com/vincentbernat/cdktf-take1": d√©p√¥t pour CDKTF
  "https://github.com/vincentbernat/nixops-take1": d√©p√¥t pour NixOps
tags:
  - distribution-nixos
---

Il y a quelques ann√©es, j'ai r√©duit mon infrastructure personnelle au strict
minimum. Jusqu'en 2018, elle repr√©sentait une douzaine de conteneurs tournant
sur un seul serveur [Hetzner][][^hetzner]. J'ai migr√© mon courriel vers
[Fastmail][] et mes zones DNS vers [Gandi][]. Il ne me restait plus que mon blog
√† h√©berger. √Ä ce jour, ma petite infrastructure est compos√©e de 4 machines
virtuelles ex√©cutant [NixOS][] sur *Hetzner Cloud* et [Vultr][], d'une poign√©e
de zones DNS sur *Gandi* et [Route 53][], et de quelques distributions
[Cloudfront][]. Elle est g√©r√©e par [CDK pour Terraform][CDK for Terraform]
(CDKTF), tandis que les d√©ploiements de *NixOS* sont g√©r√©s par [NixOps][].

Dans cet article, je pr√©sente bri√®vement *Terraform*, *CDKTF* et l'√©cosyst√®me
*Nix*. J'explique √©galement comment utiliser *Nix* pour acc√©der √† ces outils
dans votre shell afin de les utiliser rapidement.

[^hetzner]: C'√©tait un AMD Athlon 64 X2 5600+ avec 2¬†Go de RAM et 2 disques de
    400 Go en RAID logiciel. Je payais quelque chose autour de 59¬†‚Ç¨ par mois
    pour cela. Si c'√©tait une bonne affaire en 2008, en 2018, ce n'√©tait plus
    rentable. Il fonctionnait sous Debian Wheezy avec [Linux-VServer][] pour
    l'isolation, tous deux d√©pass√©s en 2018.

[TOC]

# CDKTF : infrastructure en tant que code

[Terraform][] est un outil d'¬´¬†infrastructure en tant que code¬†¬ª. Vous pouvez
d√©finir votre infrastructure en d√©clarant des ressources avec le [langage
HCL][HCL language]. Ce dernier poss√®de quelques fonctionnalit√©s suppl√©mentaires,
comme des boucles permettant de d√©clarer plusieurs ressources √† partir d'une
liste, des fonctions int√©gr√©es que vous pouvez appeler dans les expressions et
l'expansion de variables dans les cha√Ænes de caract√®res. *Terraform* s'appuie
sur un large [ensemble de fournisseurs][large set of providers] pour g√©rer les
ressources.

## G√©rer des serveurs

Voici un court exemple utilisant le [fournisseur pour Hetzner Cloud][Hetzner
Cloud provider] pour cr√©er une machine virtuelle :

```terraform
variable "hcloud_token" {
  sensitive = true
}
provider "hcloud" {
  token = var.hcloud_token
}

resource "hcloud_server" "web03" {
  name = "web03"
  server_type = "cpx11"
  image = "debian-11"
  datacenter = "nbg1-dc3"
}

resource "hcloud_rdns" "rdns4-web03" {
  server_id = hcloud_server.web03.id
  ip_address = hcloud_server.web03.ipv4_address
  dns_ptr = "web03.luffy.cx"
}

resource "hcloud_rdns" "rdns6-web03" {
  server_id = hcloud_server.web03.id
  ip_address = hcloud_server.web03.ipv6_address
  dns_ptr = "web03.luffy.cx"
}
```

L'expressivit√© de _HCL_ est assez limit√©e et je trouve qu'un langage g√©n√©raliste
est plus pratique pour d√©crire les ressources. C'est l√† qu'intervient _CDK pour
Terraform_ : vous pouvez g√©rer votre infrastructure √† l'aide de votre langage de
programmation pr√©f√©r√©, notamment TypeScript, Go et Python. Voici l'exemple
pr√©c√©dent utilisant _CDKTF_ et TypeScript :

```typescript
import { App, TerraformStack, Fn } from "cdktf";
import { HcloudProvider } from "./.gen/providers/hcloud/provider";
import * as hcloud from "./.gen/providers/hcloud";

class MyStack extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);

    const hcloudToken = new TerraformVariable(this, "hcloudToken", {
      type: "string",
      sensitive: true,
    });
    const hcloudProvider = new HcloudProvider(this, "hcloud", {
      token: hcloudToken.value,
    });
    
    const web03 = new hcloud.server.Server(this, "web03", {
      name: "web03",
      serverType: "cpx11",
      image: "debian-11",
      datacenter: "nbg1-dc3",
      provider: hcloudProvider,
    });
    new hcloud.rdns.Rdns(this, "rdns4-web03", {
      serverId: Fn.tonumber(web03.id),
      ipAddress: web03.ipv4Address,
      dnsPtr: "web03.luffy.cx",
      provider: hcloudProvider,
    });
    new hcloud.rdns.Rdns(this, "rdns6-web03", {
      serverId: Fn.tonumber(web03.id),
      ipAddress: web03.ipv6Address,
      dnsPtr: "web03.luffy.cx",
      provider: hcloudProvider,
    });
  }
}

const app = new App();
new MyStack(app, "cdktf-take1");
app.synth();
```

La commande de `cdktf synth` g√©n√®re un fichier de configuration pour
_Terraform_, `terraform plan` pr√©visualise les changements et `terraform apply`
les applique. Maintenant que vous disposez d'un langage g√©n√©raliste, vous pouvez
utiliser des fonctions.

## G√©rer des enregistrements DNS

Si l'utilisation de _CDKTF_ pour 4 serveurs web peut sembler un peu exag√©r√©e, il
en va tout autrement lorsqu'il s'agit de g√©rer quelques zones DNS. Avec
[DNSControl][], qui utilise JavaScript comme langage, j'ai pu d√©finir la zone
`bernat.ch` avec ce bout de code :

```js
D("bernat.ch", REG_NONE, DnsProvider(DNS_BIND, 0), DnsProvider(DNS_GANDI),
  DefaultTTL('2h'),
  FastMailMX('bernat.ch', {subdomains: ['vincent']}),
  WebServers('@'),
  WebServers('vincent');
```

Cela produit 38 enregistrements. Avec _CDKTF_, j'√©cris :

```ts
new Route53Zone(this, "bernat.ch", providers.aws)
  .sign(dnsCMK)
  .registrar(providers.gandiVB)
  .www("@", servers)
  .www("vincent", servers)
  .www("media", servers)
  .fastmailMX(["vincent"]);
```

Toute la magie est situ√©e dans les fonctions appel√©es. Vous pouvez regarder le
fichier [dns.ts][] dans le d√©p√¥t [cdktf-take1][] pour comprendre comment cela
fonctionne. Rapidement :

- `Route53Zone()` cr√©e une zone sur *Route 53*,
- `sign()` signe la zone avec une clef ma√Ætre,
- `registrar()` inscrit la zone aupr√®s du registre de domaines et configure DNSSEC,
- `www()` cr√©e les enregistrements `A` et `AAAA` pour les serveurs web,
- `fastmailMX()` cr√©e les enregistrements `MX` et d'autres enregistrements li√©s
  pour configurer *Fastmail* en tant que fournisseur de courriel.

Voici le contenu de la fonction `fastmailMX()`. Elle g√©n√®re quelques
enregistrements et retourne la zone en cours pour faciliter le cha√Ænage :

```ts
fastmailMX(subdomains?: string[]) {
  (subdomains ?? [])
    .concat(["@", "*"])
    .forEach((subdomain) =>
      this.MX(subdomain, [
        "10 in1-smtp.messagingengine.com.",
        "20 in2-smtp.messagingengine.com.",
      ])
    );
  this.TXT("@", "v=spf1 include:spf.messagingengine.com ~all");
  ["mesmtp", "fm1", "fm2", "fm3"].forEach((dk) =>
    this.CNAME(`${dk}._domainkey`, `${dk}.${this.name}.dkim.fmhosted.com.`)
  );
  this.TXT("_dmarc", "v=DMARC1; p=none; sp=none");
  return this;
}
```

Je vous encourage √† parcourir le [d√©p√¥t][cdktf-take1] pour plus de d√©tails !

## √Ä propos de Pulumi

Ma premi√®re tentative autour de _Terraform_ a √©t√© d'utiliser [Pulumi][]. Vous
pouvez trouver cette tentative sur [GitHub][pulumi-github]. C'est assez
similaire √† ce que je fais actuellement avec _CDKTF_. La principale diff√©rence
est que j'utilise Python au lieu de TypeScript[^python] car ce dernier ne
m'√©tait pas familier √† l'√©poque.

[^python]: Je n'ai pas non plus utilis√© Python car le support de *Poetry* dans
    *Nix* √©tait [cass√©][broken] quand j'ai commenc√© √† essayer d'utiliser
    _CDKTF_.

_Pulumi_ est ant√©rieur √† _CDKTF_ et il utilise une approche l√©g√®rement
diff√©rente. _CDKTF_ g√©n√®re une configuration pour _Terraform_ (au format JSON au
lieu de HCL), laissant la planification, la gestion des √©tats et le d√©ploiement
√† ce dernier. Il est donc li√© aux limites de ce qui peut √™tre exprim√© par
_Terraform_, notamment lorsque vous devez transformer des donn√©es obtenues d'une
ressource √† une autre[^transform]. _Pulumi_ a besoin de fournisseurs sp√©cifiques
pour chaque ressource. De nombreux fournisseurs encapsulent des fournisseurs
_Terraform_.

[^transform]: *Pulumi* peut [appliquer des fonctions arbitraires][apply
    arbitrary functions] √† l'aide de `apply()`. Cela permet de transformer les
    donn√©es qui ne sont pas connues lors de l'√©tape de planification.
    *Terraform* a des [fonctions][tf functions] pour un usage similaire mais
    elles sont plus limit√©es.

Bien que _Pulumi_ offre une bonne exp√©rience utilisateur, je suis pass√© √†
_CDKTF_ car √©crire des fournisseurs pour _Pulumi_ est une corv√©e. _CDKTF_ ne
n√©cessite pas de passer par cette √©tape. En dehors des grands acteurs (AWS,
Azure et Google Cloud), l'existence, la qualit√© et la fra√Æcheur des fournisseurs
_Pulumi_ sont in√©gales. La plupart des fournisseurs s'appuient sur un
fournisseur _Terraform_ et il se peut qu'ils soient en retard de quelques
versions, qu'il leur manque quelques ressources ou qu'ils pr√©sentent des bogues
qui leur sont propres.

Lorsqu'un fournisseur n'existe pas, vous pouvez en √©crire un √† l'aide de la
biblioth√®que [pulumi-terraform-bridge][]. Le projet Pulumi fournit un
[mod√®le][boilerplate] √† cet effet. J'ai eu une mauvaise exp√©rience avec celui-ci
lors de l'√©criture de fournisseurs pour [Gandi][provider-gandi] et
[Vultr][provider-vultr] : le `Makefile` [installe automatiquement
Pulumi][pulumi-pr51] en utilisant `curl | sh` et [ne fonctionne pas avec
`/bin/sh`][pulumi-pr52]. Il y a un manque d'int√©r√™t pour les contributions
communautaires[^maint] ou m√™me pour [les fournisseurs pour les acteurs
tiers][providers for smaller players].

[^maint]: Les deux modifications mentionn√©es ne sont pas encore fusionn√©es. La
    seconde est remplac√©e par la [PR #61][pulumi-pr61], soumise deux mois plus
    tard, qui impose l'utilisation de `/bin/bash`. J'ai √©galement soumis la
    [PR¬†#56][pulumi-pr56], qui a √©t√© fusionn√©e 4 mois plus tard et rapidement
    annul√©e sans explication.

# NixOS & NixOps

[Nix][nix-lang] est un langage de programmation purement fonctionnel.
[Nix][nix-tool] est aussi le nom du gestionnaire de paquets qui est construit
au-dessus du langage _Nix_. Il permet aux utilisateurs d'installer des paquets
de mani√®re d√©clarative. [nixpkgs][] est un d√©p√¥t de paquets. Vous pouvez
[installer _Nix_][nix-install] au-dessus d'une distribution Linux ordinaire. Si
vous voulez plus de d√©tails, une bonne ressource est le [site
officiel][nix-web], notamment la [section ¬´¬†Apprendre¬†¬ª][learn section]. La
courbe d'apprentissage est rude, mais la r√©compense est grande.

## NixOS : distribution Linux d√©clarative

[NixOS][] est une distribution Linux construite au-dessus du gestionnaire de
paquets _Nix_. Voici un bout de configuration pour ajouter quelques paquets :

```nix
environment.systemPackages = with pkgs;
  [
    bat
    htop
    liboping
    mg
    mtr
    ncdu
    tmux
  ];
```

Il est possible de modifier une d√©rivation[^derivation] existante pour utiliser une version
diff√©rente, activer une fonctionnalit√© sp√©cifique ou appliquer un correctif.
Voici comment j'active et configure _Nginx_ pour d√©sactiver le module `stream`,
ajouter le module de [compression Brotli][Brotli compression module] et ajouter
le module d'[anonymisation des adresses IP][IP address anonymizer module]. De
plus, au lieu d'utiliser _OpenSSL 3_, je continue √† utiliser _OpenSSL
1.1_[^openssl].

[^derivation]: Grosso modo, une d√©rivation est un synonyme pour paquet dans
    l'√©cosyst√®me *Nix*.

```nix
services.nginx = {
  enable = true;

  package = (pkgs.nginxStable.override {
    withStream = false;
    modules = with pkgs.nginxModules; [
      brotli
      ipscrub
    ];
    openssl = pkgs.openssl_1_1;
  });
```

Si vous avez besoin d'ajouter certaines modifications, c'est √©galement possible.
√Ä titre d'exemple, voici comment j'ai corrig√© en avance les [failles de s√©curit√©
d√©couvertes en 2019 dans *Nginx*][dos-nginx] en attendant que cela soit corrig√©
dans *NixOS*[^security] :

```nix
services.nginx.package = pkgs.nginxStable.overrideAttrs (old: {
  patches = oldAttrs.patches ++ [
    # HTTP/2: reject zero length headers with PROTOCOL_ERROR.
    (pkgs.fetchpatch {
      url = https://github.com/nginx/nginx/commit/dbdd[‚Ä¶].patch;
      sha256 = "a48190[‚Ä¶]";
    })
    # HTTP/2: limited number of DATA frames.
    (pkgs.fetchpatch {
      url = https://github.com/nginx/nginx/commit/94c5[‚Ä¶].patch;
      sha256 = "af591a[‚Ä¶]";
    })
    #  HTTP/2: limited number of PRIORITY frames.
    (pkgs.fetchpatch {
      url = https://github.com/nginx/nginx/commit/39bb[‚Ä¶].patch;
      sha256 = "1ad8fe[‚Ä¶]";
    })
  ];
});
```

[^openssl]: *OpenSSL 3* a de nombreux [probl√®mes de performance][performance regressions].

[^security]: _NixOS_ peut √™tre un peu lent √† int√©grer les correctifs car il est
    n√©cessaire de reconstruire une partie du cache binaire. Dans ce cas pr√©cis,
    cela a √©t√© rapide : la vuln√©rabilit√© et les correctifs ont √©t√© publi√©s le 13
    ao√ªt 2019 et disponibles dans NixOS le 15 ao√ªt. √Ä titre de comparaison,
    Debian n'a publi√© la version corrig√©e que le 22 ao√ªt, ce qui est
    inhabituellement tardif.

Si cela vous int√©resse, jetez un coup d'≈ìil √† ma configuration relativement
r√©duite : [`common.nix`][common.nix] contient la configuration √† appliquer sur
tous les serveurs (SSH, utilisateurs, paquets communs), [`web.nix`][web.nix]
contient la configuration pour les serveurs web et [`isso.nix`][isso.nix]
ex√©cute [Isso][] dans un conteneur _systemd_.

## NixOps : outil de d√©ploiement pour NixOS

Sur un seul n≈ìud, la configuration de _NixOS_ se trouve dans le fichier
`/etc/nixos/configuration.nix`. Apr√®s l'avoir modifi√©e, vous devez ex√©cuter la
commande `nixos-rebuild switch`. _Nix_ va chercher toutes les d√©pendances
possibles dans le cache binaire et construit le reste. Il cr√©e une nouvelle
entr√©e dans le menu du chargeur de d√©marrage et active la nouvelle
configuration.

Pour g√©rer plusieurs n≈ìuds, il existe plusieurs options, dont [NixOps][],
[deploy-rs][], [Colmena][] et [morph][]. Je ne les connais pas toutes, mais de
mon point de vue, les diff√©rences ne sont pas si importantes. Il est √©galement
possible de construire un tel outil soi-m√™me car _Nix_ fournit les blocs de
construction les plus importants : `nix build` et `nix copy`. _NixOps_ est l'un
des premiers outils publi√©s mais je vous encourage √† explorer les alternatives.

La configuration de *NixOps* est √©crite avec la langage *Nix*. Voici une
configuration simplifi√©e pour d√©ployer `znc01.luffy.cx`, `web01.luffy.cx` et
`web02.luffy.cx`, √† l'aide des fonctions `server` et `web` :

```nix
let
  server = hardware: name: imports: {
    deployment.targetHost = "${name}.luffy.cx";
    networking.hostName = name;
    networking.domain = "luffy.cx";
    imports = [ (./hardware/. + "/${hardware}.nix") ] ++ imports;
  };
  web = hardware: idx: imports:
    server hardware "web${lib.fixedWidthNumber 2 idx}" ([ ./web.nix ] ++ imports);
in {
  network.description = "Luffy infrastructure";
  network.enableRollback = true;
  defaults = import ./common.nix;
  znc01 = server "exoscale" [ ./znc.nix ];
  web01 = web "hetzner" 1 [ ./isso.nix ];
  web02 = web "hetzner" 2 [];
}
```

# Connecter le tout avec Nix

L'√©cosyst√®me _Nix_ est une solution unifi√©e aux diff√©rents probl√®mes li√©s √† la
gestion des logiciels et des configurations. Les [environnements de
d√©veloppement d√©claratifs et reproductibles][declarative and reproducible
developer environments] en constituent une caract√©ristique tr√®s int√©ressante.
Cela ressemble aux environnements virtuels de Python, mais ils ne sont pas
sp√©cifiques √† un langage.

## Courte introduction aux ¬´¬†flakes¬†¬ª Nix

J'utilise les ¬´¬†[flakes][]¬†¬ª, une nouvelle fonctionnalit√© de _Nix_ qui am√©liore
la reproductibilit√© en fixant toutes les d√©pendances et en isolant le processus
de construction. Bien que cette fonctionnalit√© soit marqu√©e comme
exp√©rimentale[^experimental], elle est de plus en plus populaire et vous pouvez
trouver `flake.nix` et `flake.lock` √† la racine de certains d√©p√¥ts.

[^experimental]: Comme les _flakes_ sont exp√©rimentaux, de nombreuses
    documentations ne les utilisent pas et c'est un aspect suppl√©mentaire √†
    apprendre.

A titre d'exemple, voici le contenu du `flake.nix` livr√© avec [Snimpy][], un
outil SNMP interactif pour Python reposant sur [libsmi][], une biblioth√®que C :

```nix
{
  inputs = {
    nixpkgs.url = "nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };
  outputs = { self, ... }@inputs:
    inputs.flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = inputs.nixpkgs.legacyPackages."${system}";
      in
      {
        # nix build
        packages.default = pkgs.python3Packages.buildPythonPackage {
          name = "snimpy";
          src = self;
          preConfigure = ''echo "1.0.0-0-000000000000" > version.txt'';
          checkPhase = "pytest";
          checkInputs = with pkgs.python3Packages; [ pytest mock coverage ];
          propagatedBuildInputs = with pkgs.python3Packages; [ cffi pysnmp ipython ];
          buildInputs = [ pkgs.libsmi ];
        };
        # nix run + nix shell
        apps.default = { 
          type = "app";
          program = "${self.packages."${system}".default}/bin/snimpy";
        };
        # nix develop
        devShells.default = pkgs.mkShell {
          name = "snimpy-dev";
          buildInputs = [
            self.packages."${system}".default.inputDerivation
            pkgs.python3Packages.ipython
          ];
        };
      });
}
```

Si *Nix* est install√© sur votre syst√®me :

- `nix run github:vincentbernat/snimpy` ex√©cute *Snimpy*,
- `nix shell github:vincentbernat/snimpy` fournit un shell avec *Snimpy* pr√™t √† √™tre utilis√©,
- `nix build github:vincentbernat/snimpy` construit le paquet Python,
- `nix develop .` fournit un shell pour d√©velopper autour de *Snimpy* depuis un
  cl√¥ne du d√©p√¥t[^checkout].

[^checkout]: Comme dans les autres exemples, il est possible de remplacer `.`
    par `github:vincentbernat/snimpy`. Cependant, obtenir les d√©pendances de
    *Snimpy* sans son code source a peu d'int√©r√™t.

Pour plus d'informations sur les *flakes*, regardez le [tutoriel de
Tweag][nix-flakes].

## Nix et CDKTF

A la racine du [d√©p√¥t que j'utilise pour CDKTF][cdktf-take1], il y a un fichier
[`flake.nix`][cdktf-take1-flake.nix] pour configurer un shell avec _Terraform_
et _CDKTF_ install√©s et avec les variables d'environnement n√©cessaires pour
automatiser mon infrastructure.

Terraform est d√©j√† pr√©sent dans _nixpkgs_, mais je dois appliquer une rustine sur
le fournisseur _Gandi_. Ce n'est pas un probl√®me avec Nix !

```nix
terraform = pkgs.terraform.withPlugins (p: [
  p.aws
  p.hcloud
  p.vultr
  (p.gandi.overrideAttrs
    (old: {
      src = pkgs.fetchFromGitHub {
        owner = "vincentbernat";
        repo = "terraform-provider-gandi";
        rev = "feature/livedns-key";
        hash = "sha256-V16BIjo5/rloQ1xTQrdd0snoq1OPuDh3fQNW7kiv/kQ=";
      };
    }))
]);
```

*CDKTF* est √©crit en TypeScript. J'ai un fichier
[`package.json`][cdktf-take1-package.json] avec toutes les d√©pendances
n√©cessaires, y compris celles pour utiliser TypeScript comme langage cible :

```json
{
  "name": "cdktf-take1",
  "version": "1.0.0",
  "main": "main.js",
  "types": "main.ts",
  "private": true,
  "dependencies": {
    "@types/node": "^14.18.30",
    "cdktf": "^0.13.3",
    "cdktf-cli": "^0.13.3",
    "constructs": "^10.1.151",
    "eslint": "^8.27.0",
    "prettier": "^2.7.1",
    "ts-node": "^10.9.1",
    "typescript": "^3.9.10",
    "typescript-language-server": "^2.1.0"
  }
}
```

J'utilise [Yarn][] pour obtenir un fichier [`yarn.lock`][cdktf-take1-yarn.lock]
qui peut ensuite √™tre utilis√© directement pour construire la d√©rivation
contenant toutes les d√©pendances :

```nix
nodeEnv = pkgs.mkYarnModules {
  pname = "cdktf-take1-js-modules";
  version = "1.0.0";
  packageJSON = ./package.json;
  yarnLock = ./yarn.lock;
};
```

L'√©tape suivant est de g√©n√©rer les fournisseurs *CDKTF* √† partir des
fournisseurs _Terraform_ et de les inclure dans une d√©rivation :

```nix
cdktfProviders = pkgs.stdenvNoCC.mkDerivation {
  name = "cdktf-providers";
  nativeBuildInputs = [
    pkgs.nodejs
    terraform
  ];
  src = nix-filter {
    root = ./.;
    include = [ ./cdktf.json ./tsconfig.json ];
  };
  buildPhase = ''
    export HOME=$(mktemp -d)
    export CHECKPOINT_DISABLE=1
    export DISABLE_VERSION_CHECK=1
    export PATH=${nodeEnv}/node_modules/.bin:$PATH
    ln -nsf ${nodeEnv}/node_modules node_modules

    # Build all providers we have in terraform
    for provider in $(cd ${terraform}/libexec/terraform-providers; echo */*/*/*); do
      version=''${provider##*/}
      provider=''${provider%/*}
      echo "Build $provider@$version"
      cdktf provider add --force-local $provider@$version | cat
    done
    echo "Compile TS ‚Üí JS"
    tsc
  '';
  installPhase = ''
    mv .gen $out
    ln -nsf ${nodeEnv}/node_modules $out/node_modules
  '';
};
```

Enfin, nous d√©finissons l'environnement de d√©veloppement :

```nix
devShells.default = pkgs.mkShell {
  name = "cdktf-take1";
  buildInputs = [
    pkgs.nodejs
    pkgs.yarn
    terraform
  ];
  shellHook = ''
    # No telemetry
    export CHECKPOINT_DISABLE=1
    # No autoinstall of plugins
    export CDKTF_DISABLE_PLUGIN_CACHE_ENV=1
    # Do not check version
    export DISABLE_VERSION_CHECK=1
    # Access to node modules
    export PATH=$PWD/node_modules/.bin:$PATH
    ln -nsf ${nodeEnv}/node_modules node_modules
    ln -nsf ${cdktfProviders} .gen

    # Credentials
    for p in \
      njf.nznmba.pbz/Nqzvavfgengbe \
      urgmare.pbz/ivaprag@oreang.pu \
      ihyge.pbz/ihyge@ivaprag.oreang.pu; do
        eval $(pass show $(echo $p | tr 'A-Za-z' 'N-ZA-Mn-za-m') | grep '^export')
    done
    eval $(pass show personal/cdktf/secrets | grep '^export')
    export TF_VAR_hcloudToken="$HCLOUD_TOKEN"
    export TF_VAR_vultrApiKey="$VULTR_API_KEY"
    unset VULTR_API_KEY HCLOUD_TOKEN
  '';
};
```

Les d√©rivations list√©es dans `buildInputs` sont disponibles dans le shell
fourni. Le contenu de `shellHook` est ex√©cut√© lors du d√©marrage du shell. Il
√©tablit des liens symboliques pour rendre disponible l'environnement JavaScript
construit √† une √©tape pr√©c√©dente, ainsi que les fournisseurs _CDKTF_ g√©n√©r√©s. Il
exporte √©galement toutes les informations d'identification[^obfuscated].

[^obfuscated]: J'utilise le gestionnaire de mots de passe [pass][]. Le nom des
    mots de passe sont brouill√©s uniquement pour √©viter les courriers
    ind√©sirables.

J'utilise √©galement [direnv][] avec un fichier [`.envrc`][cdktf-take1-envrc]
pour passer automatiquement dans l'environnement de d√©veloppement. Cela permet
√©galement √† ce dernier d'√™tre disponible depuis _Emacs_, notamment lors de
l'utilisation de [lsp-mode][] pour obtenir les compl√©tions. `nix develop .`
permet aussi d'activer manuellement l'environnement.

J'utilise les commandes suivantes pour d√©ployer[^cdktf-cli] :

```console
$ cdktf synth
$ cd cdktf.out/stacks/cdktf-take1
$ terraform plan --out plan
$ terraform apply plan
$ terraform output -json > ~-automation/nixops-take1/cdktf.json
```

[^cdktf-cli]: La commande `cdktf` sait appeler les commandes `terraform`, mais
    je pr√©f√®re les utiliser directement car elles sont plus flexibles.

La derni√®re commande produit un fichier JSON contenant les donn√©es n√©cessaires
pour finir le d√©ploiement avec _NixOps_.

## NixOps

Le [fichier JSON][cdktf-take1-cdktf.json] export√© par *Terraform* contient la
liste des serveurs avec quelques attributs :

```json
{
  "hardware": "hetzner",
  "ipv4Address": "5.161.44.145",
  "ipv6Address": "2a01:4ff:f0:b91::1",
  "name": "web05.luffy.cx",
  "tags": [
    "web",
    "continent:NA",
    "continent:SA"
  ]
}
```

Dans le fichier [`network.nix`][nixops-take1-network.nix], cette liste est
import√©e et transform√©e en un ensemble d'attributs d√©crivant les serveurs. Une
version simplifi√©e ressemble √† cela :

```nix
let
  lib = inputs.nixpkgs.lib;
  shortName = name: builtins.elemAt (lib.splitString "." name) 0;
  domainName = name: lib.concatStringsSep "." (builtins.tail (lib.splitString "." name));
  server = hardware: name: imports: {
    networking = {
      hostName = shortName name;
      domain = domainName name;
    };
    deployment.targetHost = name;
    imports = [ (./hardware/. + "/${hardware}.nix") ] ++ imports;
  };
  cdktf-servers-json = (lib.importJSON ./cdktf.json).servers.value;
  cdktf-servers = map
    (s:
      let
        tags-maybe-import = map (t: ./. + "/${t}.nix") s.tags;
        tags-import = builtins.filter (t: builtins.pathExists t) tags-maybe-import;
      in
      {
        name = shortName s.name;
        value = server s.hardware s.name tags-import;
      })
    cdktf-servers-json;
in
{
  // [‚Ä¶]
} // builtins.listToAttrs cdktf-servers
```

Pour `web05`, on obtient ceci :

```nix
web05 = {
  networking = {
    hostName = "web05";
    domainName = "luffy.cx";
  };
  deployment.targetHost = "web05.luffy.cx";
  imports = [ ./hardware/hetzner.nix ./web.nix ];
};
```

Comme pour *CDKTF*, √† la racine du [d√©p√¥t que j'utilise pour
NixOps][nixops-take1], il y a un fichier [`flake.nix`][nixops-take1-flake.nix]
pour fournir un shell avec *NixOps* configur√©. Comme *NixOps* ne supporte pas
les d√©ploiements progessifs, j'utilise g√©n√©ralement ces commandes pour d√©ployer
sur un unique serveur[^disable] :

```console
$ nix flake update
$ nixops deploy --include=web04
$ ./tests web04.luffy.cx
```

[^disable]: Si le changement est risqu√©, je [d√©sactive le serveur][disable the
    server] avec _CDKTF_. Cela le retire des enregistrements DNS.

Si les tests se d√©roulent sans soucis, je d√©ploie les autres n≈ìuds un par un
avec la commande suivante :

```console
$ (set -e; for h in web{03..06}; do nixops deploy --include=$h; done)
```

La commande `nixops deploy` d√©ploie tous les serveurs en parall√®le et peut donc
provoquer une panne si tous les serveurs *Nginx* sont indisponibles au m√™me
moment.

---

Cet article est en chantier depuis trois ans. Le contenu a √©t√© mis √† jour et
affin√© au fur et √† mesure de mes exp√©rimentations. Il y a encore beaucoup √†
explorer[^todo], mais j'estime que le contenu est d√©sormais suffisant pour √™tre
publi√© ! üéÑ

[^todo]: Je voudrais remplacer *NixOps* avec une alternative g√©rant les
    d√©ploiements progressifs et les tests. Je voudrais aussi passer √† [Nomad][]
    ou *Kubernetes* pour d√©ployer les applications.

*[HCL]: HashiCorp Configuration Language
*[CDKTF]: Cloud Development Kit for Terraform
[fastmail]: https://www.fastmail.com/
[hetzner]: https://www.hetzner.com/ "Hetzner: dedicated servers, cloud, storage & hosting"
[linux-vserver]: http://linux-vserver.org/Welcome_to_Linux-VServer.org "Linux-VServer"
[gandi]: https://www.gandi.net/en "Gandi: Domain Names, Web Hosting, Mail"
[nixos]: https://nixos.org/ "Nix: reproducible builds and deployments"
[pulumi]: https://www.pulumi.com/ "Pulumi: universal infrastructure as code"
[route 53]: https://aws.amazon.com/route53/ "Amazon AWS: Route 53"
[cloudfront]: https://aws.amazon.com/cloudfront/ "Amazon AWS: CloudFront"
[cdk for terraform]: https://developer.hashicorp.com/terraform/cdktf "Cloud Development Kit for Terraform"
[nixops]: https://github.com/NixOS/nixops "NixOps:  tool for deploying to NixOS machines in a network or cloud"
[pulumi-github]: https://github.com/vincentbernat/pulumi-take1
[apply arbitrary functions]: https://www.pulumi.com/docs/intro/concepts/inputs-outputs/#apply
[tf functions]: https://developer.hashicorp.com/terraform/language/functions
[pulumi-terraform-bridge]: https://github.com/pulumi/pulumi-terraform-bridge
[boilerplate]: https://github.com/pulumi/pulumi-tf-provider-boilerplate
[provider-gandi]: https://github.com/vincentbernat/pulumi-gandi-old "Deprecated Pulumi provider for Gandi"
[provider-vultr]: https://github.com/vincentbernat/pulumi-vultr "Pulumi provider for Vultr"
[pulumi-pr51]: https://github.com/pulumi/pulumi-tf-provider-boilerplate/pull/51 "PR #51: Do not install pulumi automatically"
[pulumi-pr52]: https://github.com/pulumi/pulumi-tf-provider-boilerplate/pull/52 "PR #52: Fix Makefile to work with a POSIX shell"
[pulumi-pr61]: https://github.com/pulumi/pulumi-tf-provider-boilerplate/pull/61 "PR #61: Explicitly specify bash as shell in Makefile"
[pulumi-pr56]: https://github.com/pulumi/pulumi-tf-provider-boilerplate/pull/56 "PR #56: Use go:embed instead of go generate for schema"
[pulumi-pr66]: https://github.com/pulumi/pulumi-tf-provider-boilerplate/pull/66 "PR #66: Revert ‚ÄúUse go:embed instead of go generate for schema‚Äù"
[providers for smaller players]: https://twitter.com/briggsl/status/1473009153983623176
[nix-lang]: https://nixos.org/manual/nix/stable/language/index.html "Nix, the language"
[nix-tool]: https://nixos.org/manual/nix/stable/introduction.html "Nix, the package manager"
[nixpkgs]: https://github.com/NixOS/nixpkgs
[ChatGPT]: https://chat.openai.com/chat
[nix-install]: https://nixos.org/manual/nix/stable/installation/multi-user.html
[nix-web]: https://nixos.org/
[nix.dev]: https://nix.dev/
[learn section]: https://nixos.org/learn.html
[nix-flakes]: https://www.tweag.io/blog/2020-05-25-flakes/ "Nix Flakes, Part 1: An introduction and tutorial"
[declarative and reproducible developer environments]: https://nixos.org/guides/declarative-and-reproducible-developer-environments.html
[terraform]: https://www.terraform.io/
[hcl language]: https://developer.hashicorp.com/terraform/language/modules
[large set of providers]: https://registry.terraform.io/browse/providers
[scaleway provider]: https://registry.terraform.io/providers/scaleway/scaleway/latest/docs
[puppet language]: https://puppet.com/docs/puppet/7/puppet_language.html
[hetzner cloud provider]: https://registry.terraform.io/providers/hetznercloud/hcloud/latest/docs
[dns.ts]: https://github.com/vincentbernat/cdktf-take1/blob/main/luffy/dns.ts
[cdktf-take1]: https://github.com/vincentbernat/cdktf-take1
[brotli compression module]: https://github.com/google/ngx_brotli
[ip address anonymizer module]: https://github.com/masonicboom/ipscrub
[performance regressions]: https://github.com/openssl/openssl/issues/17627#issuecomment-1060123659
[dos-nginx]: https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md 
[isso]: [[en/blog/2020-docker-nixos-isso.html]] "Running Isso on NixOS in a Docker container"
[web.nix]: https://github.com/vincentbernat/nixops-take1/blob/master/web.nix
[common.nix]: https://github.com/vincentbernat/nixops-take1/blob/master/common.nix
[isso.nix]: https://github.com/vincentbernat/nixops-take1/blob/master/isso.nix
[deploy-rs]: https://github.com/serokell/deploy-rs "simple multi-profile Nix flake deploy tool"
[morph]: https://github.com/DBCDK/morph/ "NixOS deployment tool"
[colmena]: https://github.com/zhaofengli/colmena "Simple, stateless NixOS deployment tool"
[akvorado]: [[en/blog/2022-akvorado-flow-collector.html]] "Akvorado: a flow collector, enricher, and visualizer"
[snimpy]: [[en/blog/2013-snimpy.html]] "Snimpy: SNMP & Python"
[cdktf-take1-flake.nix]: https://github.com/vincentbernat/cdktf-take1/blob/main/flake.nix
[cdktf-take1-package.json]: https://github.com/vincentbernat/cdktf-take1/blob/main/package.json 
[cdktf-take1-yarn.lock]: https://github.com/vincentbernat/cdktf-take1/blob/main/yarn.lock
[cdktf-take1-envrc]: https://github.com/vincentbernat/cdktf-take1/blob/main/.envrc
[yarn]: https://yarnpkg.com/ "Yarn package manager"
[pass]: https://www.passwordstore.org/ "The standard Unix password manager"
[direnv]: https://github.com/direnv/direnv/ "direnv: unclutter your .profile"
[lsp-mode]: https://github.com/emacs-lsp/lsp-mode/ "Language Server Protocol Support for Emacs"
[nixops-take1]: https://github.com/vincentbernat/nixops-take1
[nixops-take1-flake.nix]: https://github.com/vincentbernat/nixops-take1/blob/master/flake.nix
[nixops-take1-network.nix]: https://github.com/vincentbernat/nixops-take1/blob/master/network.nix
[libsmi]: https://www.ibr.cs.tu-bs.de/projects/libsmi/ "libsmi: library to Access SMI MIB Information"
[flakes]: https://nixos.wiki/wiki/Flakes "Flakes on NixOS wiki"
[cdktf-take1-cdktf.json]: https://github.com/vincentbernat/nixops-take1/blob/master/cdktf.json
[disable the server]: https://github.com/vincentbernat/cdktf-take1/commit/606e6fb657179408b163664dd74ff5ab38b28246
[vultr]: https://www.vultr.com/ "Vultr.com: SSD VPS Servers, Cloud Servers and Cloud Hosting"
[nomad]: https://www.nomadproject.io/ "Nomad: Orchestration Made Easy"
[broken]: https://github.com/nix-community/poetry2nix/issues/750 "Issue #750: infinite recursion"
[dnscontrol]: https://stackexchange.github.io/dnscontrol/ "DNSControl: Synchronize your DNS to multiple providers from a simple DSL"
