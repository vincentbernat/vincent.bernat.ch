---
title: "VPN rout√© avec Linux et WireGuard"
description: |
  Impl√©mentation de VPN site-√†-site redondants sous Linux √† l'aide de
  WireGuard (plut√¥t qu'IPsec) et BGP.
uuid: 9c77c0f3-f5ab-4403-b2e9-666dfa56ea02
attachments:
  "https://github.com/vincentbernat/network-lab/tree/master/lab-routed-vpn-wireguard": "D√©p√¥t GitHub"
tags:
  - network
---

Dans un [article pr√©c√©dent][previous article], j'ai d√©crit l'impl√©mentation de
VPN site-√†-site redondants avec IPsec (en utilisant [strongSwan][] comme d√©mon
IKE) et BGP (avec [BIRD][]) pour r√©aliser ceci : ü¶ë

![VPN redondants entre trois sites]([[!!images/vpn-routed.svg]] "Trois sites reli√©s de mani√®re redondante √† l'aide de VPN IPsec.")

Les deux forces principales d'une telle installation sont :

1. Les **d√©mons de routage** distribuent les routes √† prot√©ger sur chaque
   site. Ils apportent la haute disponibilit√© et facilitent grandement la
   configuration quand de nombreux sous-r√©seaux sont pr√©sents.
2. L'encapsulation et la d√©capsulation sont ex√©cut√©s dans un **espace de noms
   r√©seau diff√©rent**. Cela permet de cloisonner efficacement le routage priv√©
   (o√π les utilisateurs du VPN se trouvent) du routage public (o√π les
   terminaisons VPN se trouvent).

En alternative √† IPsec, [WireGuard][] un VPN extr√™mement simple (moins de 5 000
lignes de code) mais rapide et moderne qui utilise la derni√®re g√©n√©ration
d'algorithmes cryptographiques ([Curve25519][], [ChaCha20][], [Poly1305][]) et
dont le protocole, bas√© sur [Noise][], a √©t√© [formellement v√©rifi√©][formally
verified]. Il est disponible comme un module externe pour Linux mais sera
probablement int√©gr√© une fois que le protocole sera d√©finitif. Par rapport √†
IPsec, sa faiblesse majeure est son manque d'interop√©rabilit√©.

Il peut ais√©ment remplacer *strongSwan* dans notre installation VPN
site-√†-site. Sous Linux, il se base sur des interfaces virtuelles et du
routage. La premi√®re √©tape consiste √† cr√©er, pour chaque VPN, une clef priv√©e et
d'en extraire la clef publique associ√©e :

    ::console
    $ wg genkey
    oM3PZ1Htc7FnACoIZGhCyrfeR+Y8Yh34WzDaulNEjGs=
    $ echo oM3PZ1Htc7FnACoIZGhCyrfeR+Y8Yh34WzDaulNEjGs= | wg pubkey
    hV1StKWfcC6Yx21xhFvoiXnWONjGHN1dFeibN737Wnc=

Ensuite, pour chaque VPN distant, nous cr√©ons un court fichier de
configuration[^simplicity]¬†:

    ::ini
    [Interface]
    PrivateKey = oM3PZ1Htc7FnACoIZGhCyrfeR+Y8Yh34WzDaulNEjGs=
    ListenPort = 5803
    
    [Peer]
    PublicKey  = Jixsag44W8CFkKCIvlLSZF86/Q/4BovkpqdB9Vps5Sk=
    EndPoint   = [2001:db8:2::1]:5801
    AllowedIPs = 0.0.0.0/0,::/0

[^simplicity]: Par rapport √† IPsec, les algorithmes cryptographiques utilis√©s ne
    peuvent pas √™tre modifi√©s. Cela √©vite l'utilisation d'algorithmes trop
    faibles.

Une valeur diff√©rente pour `ListenPort` est choisie pour chaque VPN
distant. *WireGuard* peut communiquer avec plusieurs passerelles sur le m√™me
port UDP mais cela n'est pas possible ici en raison du routage dynamique. La
directive `AllowedIPs` indique d'accepter n'importe quel trafic.

L'√©tape suivante consiste √† configurer les interfaces tunnel pour chaque VPN
distant :

    ::console
    $ ip link add dev wg3 type wireguard
    $ wg setconf wg3 wg3.conf

*WireGuard* n√©gocie alors des clefs sym√©triques avec chaque pair :

    ::console hl_lines="10"
    $ wg show wg3
    interface: wg3
      public key: hV1StKWfcC6Yx21xhFvoiXnWONjGHN1dFeibN737Wnc=
      private key: (hidden)
      listening port: 5803
    
    peer: Jixsag44W8CFkKCIvlLSZF86/Q/4BovkpqdB9Vps5Sk=
      endpoint: [2001:db8:2::1]:5801
      allowed ips: 0.0.0.0/0, ::/0
      latest handshake: 55 seconds ago
      transfer: 49.84 KiB received, 49.89 KiB sent

Comme les interfaces VTI, les interfaces tunnel de *WireGuard* prennent en
compte les espaces de noms : une fois cr√©√©es, elles peuvent √™tre d√©plac√©es dans
un espace de noms diff√©rent dans lequel le trafic en clair sera encapsul√© et
d√©capsul√©. Le trafic chiffr√© est rout√© dans l'espace de noms
d'origine. D√©pla√ßons chaque interface dans l'espace de noms `private` et
assignons leur une adresse IP :

    ::console
    $ ip link set netns private dev wg3
    $ ip -n private addr add 2001:db8:ff::/127 dev wg3
    $ ip -n private link set wg3 up

Le VPN distant correspondant utilise l'adresse `2001:db8:ff::1/127`. Une fois
que tout est en place, il devient possible depuis un VPN d'atteindre ses
voisins¬†:

    ::console
    $ ip netns exec private fping 2001:db8:ff::{1,3,5,7}
    2001:db8:ff::1 is alive
    2001:db8:ff::3 is alive
    2001:db8:ff::5 is alive
    2001:db8:ff::7 is alive

La configuration de *BIRD* est inchang√©e par rapport √† la [pr√©c√©dente
installation][previous article] et les sessions BGP doivent s'√©tablir
rapidement¬†:

    ::console
    $ birdc6 -s /run/bird6.private.ctl show proto | grep IBGP_
    IBGP_V2_1 BGP      master   up     20:16:31    Established
    IBGP_V2_2 BGP      master   up     20:16:31    Established
    IBGP_V3_1 BGP      master   up     20:16:31    Established
    IBGP_V3_2 BGP      master   up     20:16:29    Established

Les routes distantes sont apprises √† travers les interfaces tunnel¬†:

    ::console
    $ ip -6 -n private route show proto bird
    2001:db8:a1::/64 via fe80::5254:33ff:fe00:13 dev eth2 metric 1024 pref medium
    2001:db8:a2::/64 metric 1024
            nexthop via 2001:db8:ff::1 dev wg3 weight 1
            nexthop via 2001:db8:ff::3 dev wg4 weight 1
    2001:db8:a3::/64 metric 1024
            nexthop via 2001:db8:ff::5 dev wg5 weight 1
            nexthop via 2001:db8:ff::7 dev wg6 weight 1

Depuis un site, il devient possible d'atteindre un h√¥te d'un autre site √†
travers les VPN¬†:

    ::console
    $ ping -c 2 2001:db8:a3::1
    PING 2001:db8:a3::1(2001:db8:a3::1) 56 data bytes
    64 bytes from 2001:db8:a3::1: icmp_seq=1 ttl=62 time=1.54 ms
    64 bytes from 2001:db8:a3::1: icmp_seq=2 ttl=62 time=1.67 ms
    
    --- 2001:db8:a3::1 ping statistics ---
    2 packets transmitted, 2 received, 0% packet loss, time 1001ms
    rtt min/avg/max/mdev = 1.542/1.607/1.672/0.065 ms

Comme avec IPsec, vous pouvez observer le trafic en clair avec `tcpdump`¬†:

    ::console
    $ ip netns exec private tcpdump -c3 -pni wg5 icmp6
    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
    listening on wg5, link-type RAW (Raw IP), capture size 262144 bytes
    08:34:34 IP6 2001:db8:a3::1 > 2001:db8:a1::1: ICMP6, echo reply, seq 40
    08:34:35 IP6 2001:db8:a3::1 > 2001:db8:a1::1: ICMP6, echo reply, seq 41
    08:34:36 IP6 2001:db8:a3::1 > 2001:db8:a1::1: ICMP6, echo reply, seq 42
    3 packets captured
    3 packets received by filter
    0 packets dropped by kernel

Tous les fichiers de configuration sont disponibles sur [GitHub][].

*[IKE]: Internet Key Exchange
*[ESP]: Encapsulating Security Payload
*[SPI]: Security Parameters Index
*[VRF]: Virtual routing and forwarding
*[VTI]: Virtual Tunnel Interface
*[GRE]: Generic Routing Encapsulation
*[MTU]: Maximum Transmission Unit
*[PMTUD]: Path MTU discovery

[previous article]: [[fr/blog/2017-vpn-ipsec-route.html]] "VPN IPsec rout√© avec Linux et strongSwan"
[strongSwan]: https://strongswan.org/ "strongSwan: the OpenSource IPsec-based VPN Solution"
[GitHub]: https://github.com/vincentbernat/network-lab/blob/master/lab-routed-vpn-wireguard "Configuration files for route-based VPNs with WireGuard"
[BIRD]: http://bird.network.cz/ "The BIRD Internet Routing Daemon"
[WireGuard]: https://www.wireguard.com/ "WireGuard: fast, modern, secure VPN tunnel"
[Noise]: http://www.noiseprotocol.org/ "Noise Protocol Framework"
[Curve25519]: http://cr.yp.to/ecdh.html "Curve25519: high-speed ellipitic-curve cryptography"
[ChaCha20]: http://cr.yp.to/chacha.html "The ChaCha family of stream ciphers"
[Poly1305]: http://cr.yp.to/mac.html "Poly1305-AES: a state-of-the-art message-authentication code"
[formally verified]: https://www.wireguard.com/formal-verification/ "WireGuard: formal verification using Tamarin"

{# Local Variables:      #}
{# mode: markdown        #}
{# indent-tabs-mode: nil #}
{# fill-column: 80       #}
{# End:                  #}
