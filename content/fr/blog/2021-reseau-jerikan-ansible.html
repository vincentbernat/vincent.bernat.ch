---
title: "Jerikan+Ansible : un syst√®me de gestion de configuration pour le r√©seau"
author: ex-Blade Network Team
github: jerikan-network
description: |
  Jerikan est un outil destin√© aux √©quipes r√©seau. Il g√©n√®re des fichiers de configuration
  √† partir d'une source de v√©rit√© et de mod√®les. Le d√©ploiement est ensuite confi√© √† Ansible.
uuid: c6fb13a5-2787-4525-83d5-6f99b5083e6c
attachments:
  "https://github.com/jerikan-network/cmdb": D√©p√¥t GitHub
cover: jerikan/templates@2x.jpg
tags:
  - network-automation
---

Il existe de nombreuses ressources pour l'automatisation du r√©seau
avec [Ansible][]. La plupart d'entre elles n'exposent que les
[premi√®res √©tapes][first steps] ou se limitent √† un [champ
d'application r√©duit][narrow scope]. Elles donnent peu d'indications
sur la mani√®re d'aller plus loin. Les environnements r√©seau
r√©els peuvent √™tre vastes, polyvalents, h√©t√©rog√®nes et remplis
d'exceptions. L'absence d'exemples concrets de d√©ploiements Ansible,
contrairement √† [Puppet][] et [SaltStack][], conduit de nombreuses
√©quipes √† √©laborer des solutions fragiles et incompl√®tes.

Nous avons [publi√©][Jerikan] sous une licence libre notre tentative
pour pallier √† ce manque :

 - **Jerikan**, un outil pour construire des fichiers de configuration
   √† partir d'une *source de v√©rit√© unique* et de *mod√®les
   [Jinja2][]*, ainsi que son int√©gration dans *GitLab*,
 - un **playbook Ansible** pour d√©ployer ces fichiers de configuration
   sur les √©quipements r√©seau,
 - les **donn√©es de configuration et les mod√®les** pour nos centres de
   donn√©es, aujourd'hui ferm√©s, √† San Francisco et en Cor√©e du Sud,
   couvrant de nombreux fournisseurs (Facebook Wedge 100, Dell S4048
   et S6010, Juniper QFX 5110, Juniper QFX 10002, Cisco ASR 9001,
   Cisco Catalyst 2960, serveurs de console Opengear et serveurs
   Linux) et de nombreuses fonctionnalit√©s (approvisionnement, routage
   BGP vers l'h√¥te, routage Internet, r√©seau d'administration s√©par√©,
   configuration DNS, int√©gration avec NetBox et les IRR).

Voici une d√©mo pour l'ajout d'un nouveau peering:

![]([[!!videos/2021-network-cmdb.m3u8]])

Ce travail est l'≈ìuvre collective de [C√©dric Hasco√´t][],
[Jean-Christophe Legatte][], [Lo√Øc Pailhas][], [S√©bastien Hurtel][],
[Tchadel Icard][] et [Vincent Bernat][]. Nous sommes l'√©quipe r√©seau
de Blade, une soci√©t√© fran√ßaise exploitant [Shadow][], un produit de
PC dans les nuages. En mai 2021, notre soci√©t√© a √©t√© [rachet√©e par
Octave Klaba][was bought by Octave Klaba] et l'infrastructure est en
cours de transfert vers [OVHcloud][], sauvant ainsi *Shadow* en tant
que produit, mais rendant notre √©quipe superflue.

Notre r√©seau comptait environ 800 √©quipements, r√©partis sur 10 centres
de donn√©es avec plus de 2,5 Tbps de bande passante disponible en
sortie. Le mat√©riel publi√© est donc un exemple substantiel de gestion
d'un r√©seau de taille moyenne √† l'aide d'*Ansible*. Nous avons laiss√©
de c√¥t√© la configuration de nos centres de donn√©es plus anciens pour
rendre le r√©sultat final plus lisible, tout en conservant suffisamment
de substance pour ne pas en faire un exemple trivial.

[TOC]

# Jerikan

Le premier composant est *Jerikan*. En entr√©e, il prend une liste
d'√©quipements, des donn√©es de configuration, des mod√®les et des
scripts de validation. Il g√©n√®re un ensemble de fichiers de
configuration pour chaque appareil. *Ansible* pourrait effectuer cette
t√¢che, mais il pr√©sente les limitations suivantes concernant la
compilation des mod√®les :

 - il est lent,
 - les erreurs sont difficiles √† corriger[^debug],
 - la hi√©rarchie de recherche d'une variable est [rigide][rigid].

[^debug]: *Ansible* ne fournit m√™me pas un num√©ro de ligne lorsqu'il y
    a une erreur dans un mod√®le. Il faut parfois trouver le probl√®me
    par bissection.

        ::console
        {% raw %}
        $ ansible --version
        ansible 2.10.8
        [‚Ä¶]
        $ cat test.j2
        Hello {{ name }}!
        $ ansible all -i localhost, \
        >  --connection=local \
        >  -m template \
        >  -a "src=test.j2 dest=test.txt"
        localhost | FAILED! => {
            "changed": false,
            "msg": "AnsibleUndefinedVariable: 'name' is undefined"
        }
        {% endraw %}

![Entr√©es et sorties de Jerikan]([[!!images/jerikan/jerikan.svg]]
"Entr√©es et sorties de Jerikan")

Si vous voulez suivre les exemples, il vous suffit d'avoir install√©
[Docker][] et [Docker Compose][]. Clonez le [d√©p√¥t][Jerikan] et vous
√™tes pr√™t !

## Source de v√©rit√©

Nous utilisons des fichiers YAML, versionn√©s avec *Git*, comme source
de v√©rit√© unique au lieu d'utiliser une base de donn√©es, comme NetBox,
ou un m√©lange de base de donn√©es et de fichiers texte. Cela offre de
nombreux avantages :

 - chacun peut utiliser son √©diteur de texte pr√©f√©r√©,
 - l'√©quipe pr√©pare les changements dans des branches,
 - l'√©quipe √©value les changements en utilisant des *demandes de fusion*,
 - les demandes de fusion pr√©sentent l'impact sur les fichiers de configuration g√©n√©r√©s,
 - le retour √† un √©tat ant√©rieur est facile,
 - c'est rapide.

Le premier fichier est [`devices.yaml`][devices.yaml]. Il contient la
liste des √©quipements. Le deuxi√®me fichier est
[`classifier.yaml`][classifier.yaml]. Il d√©finit un ensemble de
cl√©s-valeurs pour chaque √©quipement. Il est utilis√© dans les mod√®les
et pour rechercher les donn√©es associ√©es √† un appareil.

    ::console
    $ ./run-jerikan scope to1-p1.sk1.blade-group.net
    continent: apac
    environment: prod
    groups:
    - tor
    - tor-bgp
    - tor-bgp-compute
    host: to1-p1.sk1
    location: sk1
    member: '1'
    model: dell-s4048
    os: cumulus
    pod: '1'
    shorthost: to1-p1

Le nom de l'√©quipement est compar√© √† une liste d'expressions
r√©guli√®res et chaque correspondance contribue au r√©sultat. Pour
`to1-p1.sk1.blade-group.net`, le sous-ensemble suivant de
`classifier.yaml` d√©finit ses variables :

    ::yaml
    matchers:
      - '^(([^.]*)\..*)\.blade-group\.net':
          environment: prod
          host: '\1'
          shorthost: '\2'
      - '\.(sk1)\.':
          location: '\1'
          continent: apac
      - '^to([12])-[as]?p(\d+)\.':
          member: '\1'
          pod: '\2'
      - '^to[12]-p\d+\.':
          groups:
            - tor
            - tor-bgp
            - tor-bgp-compute
      - '^to[12]-(p|ap)\d+\.sk1\.':
          os: cumulus
          model: dell-s4048

Le troisi√®me fichier est [`searchpaths.py`][searchpaths.py]. Il d√©crit
les r√©pertoires √† examiner pour trouver une variable. Une fonction
Python fournit une liste de chemins dans [`data/`][data] selon les
variables associ√©es √† l'√©quipement. Voici une version
simplifi√©e[^jerakia] :

    ::python
    def searchpaths(scope):
        paths = [
            "host/{scope[location]}/{scope[shorthost]}",
            "location/{scope[location]}",
            "os/{scope[os]}-{scope[model]}",
            "os/{scope[os]}",
            'common'
        ]
        for idx in range(len(paths)):
            try:
                paths[idx] = paths[idx].format(scope=scope)
            except KeyError:
                paths[idx] = None
        return [path for path in paths if path]

[^jerakia]: Ce sont les m√™mes concepts que dans [Hiera][],
    le syst√®me cl√©s-valeurs hi√©rarchique de *Puppet*. Au d√©part, nous
    utilisions [Jerakia][], un syst√®me similaire ind√©pendant qui
    expose une interface HTTP REST. Cependant, le surco√ªt en temps
    d'une recherche est trop important pour notre utilisation.
    *Jerikan* impl√©mente la m√™me fonctionnalit√© dans une [fonction
    Python][Python function].

Avec cette d√©finition, les donn√©es pour `to1-p1.sk1.blade-group.net`
sont recherch√©es dans les chemins suivants :

    ::console
    $ ./run-jerikan scope to1-p1.sk1.blade-group.net
    [‚Ä¶]
    Search paths:
      host/sk1/to1-p1
      location/sk1
      os/cumulus-dell-s4048
      os/cumulus
      common

Les variables sont limit√©es √† un espace de noms √† sp√©cifier lors d'une
recherche. Nous utilisons les suivants :

 - `system` pour les comptes, DNS, serveurs syslog, ...
 - `topology` pour les ports, interfaces, adresses IP, sous-r√©seaux, ...
 - `bgp` pour la configuration de BGP
 - `build` pour les mod√®les et les scripts de validation
 - `apps` pour les variables d'application

Lors de la recherche d'une variable dans un espace de noms donn√©,
*Jerikan* recherche un fichier YAML nomm√© d'apr√®s l'espace de noms
dans chaque r√©pertoire retourn√©s par la fonction de recherche. Par
exemple, si nous recherchons une variable pour
`to1-p1.sk1.blade-group.net` dans l'espace de noms `bgp`, les fichiers
YAML suivants sont trait√©s : `host/sk1/to1-p1/bgp.yaml`,
`location/sk1/bgp.yaml`, `os/cumulus-dell-s4048/bgp.yaml`,
`os/cumulus/bgp.yaml` et `common/bgp.yaml`. La recherche s'arr√™te √†
la premi√®re correspondance.

Le fichier [`schema.yaml`][schema.yaml] nous permet d'outrepasser ce
dernier comportement en fusionnant dans certains cas les dictionnaires
et les tableaux correspondants. Voici un extrait de ce fichier pour
l'espace de noms `topology` :

    ::yaml
    system:
      users:
        merge: hash
      sampling:
        merge: hash
      ansible-vars:
        merge: hash
      netbox:
        merge: hash

La derni√®re fonctionnalit√© de la source de v√©rit√© est la possibilit√©
d'utiliser des mod√®les [Jinja2][] pour les clefs et les valeurs en les
pr√©fixant par ¬´¬†`~`¬†¬ª¬†:

    ::yaml
    {% raw %}
    # Dans data/os/junos/system.yaml
    netbox:
      manufacturer: Juniper
      model: "~{{ model|upper }}"

    # Dans data/groups/tor-bgp-compute/system.yaml
    netbox:
      role: net_tor_gpu_switch
    {% endraw %}

Chercher `netbox` dans l'espace de noms `system` pour
`to1-p2.ussfo03.blade-group.net` produit le r√©sultat suivant :

    ::console
    $ ./run-jerikan scope to1-p2.ussfo03.blade-group.net
    continent: us
    environment: prod
    groups:
    - tor
    - tor-bgp
    - tor-bgp-compute
    host: to1-p2.ussfo03
    location: ussfo03
    member: '1'
    model: qfx5110-48s
    os: junos
    pod: '2'
    shorthost: to1-p2
    [‚Ä¶]
    Search paths:
    [‚Ä¶]
      groups/tor-bgp-compute
    [‚Ä¶]
      os/junos
      common
    $ ./run-jerikan lookup to1-p2.ussfo03.blade-group.net system netbox
    manufacturer: Juniper
    model: QFX5110-48S
    role: net_tor_gpu_switch

Cela fonctionne aussi pour des donn√©es structur√©es :

    ::yaml
    {% raw %}
    # Dans groups/adm-gateway/topology.yaml
    interface-rescue:
      address: "~{{ lookup('topology', 'addresses').rescue }}"
      up:
        - "~ip route add default via {{ lookup('topology', 'addresses').rescue|ipaddr('first_usable') }} table rescue"
        - "~ip rule add from {{ lookup('topology', 'addresses').rescue|ipaddr('address') }} table rescue priority 10"

    # Dans groups/adm-gateway-sk1/topology.yaml
    interfaces:
      ens1f0: "~{{ lookup('topology', 'interface-rescue') }}"
    {% endraw %}

Cela retourne le r√©sultat suivant :

    ::console
    $ ./run-jerikan lookup gateway1.sk1.blade-group.net topology interfaces
    [‚Ä¶]
    ens1f0:
      address: 121.78.242.10/29
      up:
      - ip route add default via 121.78.242.9 table rescue
      - ip rule add from 121.78.242.10 table rescue priority 10

Pour placer des donn√©es dans la source de v√©rit√©, nous utilisons les
r√®gles suivantes :

 1. Ne pas se r√©p√©ter.
 2. Pr√©f√©rer l'emplacement le plus sp√©cifique sans enfreindre la premi√®re r√®gle.
 3. Utiliser avec parcimonie les mod√®les, principalement pour respecter les r√®gles pr√©c√©dentes.
 4. Limiter le mod√®le de donn√©es √† ce qui est n√©cessaire pour votre cas d'utilisation.

La premi√®re r√®gle est assez importante. Par exemple, lorsque vous
sp√©cifiez des adresses IP pour une liaison point √† point, ne sp√©cifiez
qu'un c√¥t√© et d√©duisez l'autre valeur via les mod√®les. La derni√®re
r√®gle signifie qu'il est inutile de reproduire un [mod√®le BGP
YANG][BGP YANG model] pour sp√©cifier les pairs et les politiques BGP :

    ::yaml
    peers:
      transit:
        cogent:
          asn: 174
          remote:
            - 38.140.30.233
            - 2001:550:2:B::1F9:1
          specific-import:
            - name: ATT-US
              as-path: ".*7018$"
              lp-delta: 50
      ix-sfmix:
        rs-sfmix:
          monitored: true
          asn: 63055
          remote:
            - 206.197.187.253
            - 206.197.187.254
            - 2001:504:30::ba06:3055:1
            - 2001:504:30::ba06:3055:2
        blizzard:
          asn: 57976
          remote:
            - 206.197.187.42
            - 2001:504:30::ba05:7976:1
          irr: AS-BLIZZARD

## Mod√®les

La liste des mod√®les √† compiler pour chaque √©quipement est stock√©e
dans la source de v√©rit√©, sous l'espace de noms `build` :

    ::console
    $ ./run-jerikan lookup edge1.ussfo03.blade-group.net build templates
    data.yaml: data.j2
    config.txt: junos/main.j2
    config-base.txt: junos/base.j2
    config-irr.txt: junos/irr.j2
    $ ./run-jerikan lookup to1-p1.ussfo03.blade-group.net build templates
    data.yaml: data.j2
    config.txt: cumulus/main.j2
    frr.conf: cumulus/frr.j2
    interfaces.conf: cumulus/interfaces.j2
    ports.conf: cumulus/ports.j2
    dhcpd.conf: cumulus/dhcp.j2
    default-isc-dhcp: cumulus/default-isc-dhcp.j2
    authorized_keys: cumulus/authorized-keys.j2
    motd: linux/motd.j2
    acl.rules: cumulus/acl.j2
    rsyslog.conf: cumulus/rsyslog.conf.j2

Les mod√®les utilisent [Jinja2][]. C'est le m√™me moteur que pour
*Ansible*. *Jerikan* fournit quelques filtres personnalis√©s mais
r√©utilise √©galement certains des filtres d'*Ansible*[^extend],
notamment [`ipaddr`][ipaddr]. Voici un extrait de
[`templates/junos/base.j2`][templates/junos/base.j2] pour configurer
les serveurs DNS et NTP sur les √©quipements Juniper :

    ::jinja
    {% raw %}
    system {
      ntp {
    {% for ntp in lookup("system", "ntp") %}
        server {{ ntp }};
    {% endfor %}
      }
      name-server {
    {% for dns in lookup("system", "dns") %}
        {{ dns }};
    {% endfor %}
      }
    }
    {% endraw %}

Voici le mod√®le √©quivalent pour Cisco IOS-XR :

    ::jinja
    {% raw %}
    {% for dns in lookup('system', 'dns') %}
    domain vrf VRF-MANAGEMENT name-server {{ dns }}
    {% endfor %}
    !
    {% for syslog in lookup('system', 'syslog') %}
    logging {{ syslog }} vrf VRF-MANAGEMENT
    {% endfor %}
    !
    {% endraw %}


[^extend]: La liste des filtres est plac√©e en dur dans
    [`jerikan/jinja.py`][jerikan/jinja.py]. C'est une cons√©quence du
    fait que nous ne maintenons pas *Jerikan* comme un logiciel
    ind√©pendant.

Trois fonctions utiles sont fournies :

 - `devices()` renvoie la liste des √©quipements correspondant √† un
   ensemble de conditions. Par exemple, `devices("location==ussfo03",
   "groups==tor-bgp")` renvoie la liste des routeurs de San Francisco
   appartenant au groupe `tor-bgp`. Vous pouvez √©galement omettre
   l'op√©rateur si vous souhaitez que la valeur sp√©cifi√©e soit √©gale √†
   celle de l'√©quipement en cours. Par exemple, `devices("location")`
   renvoie les √©quipements situ√©s dans le lieu actuel.
 - `lookup()` effectue une recherche par cl√©. Elle prend l'espace de
   noms, la cl√©, et optionellement, un nom d'√©quipement. S'il n'est
   pas fourni, la recherche s'effectue sur l'√©quipement actuel.
 - `scope()` renvoie les variables associ√©es √† l'√©quipement indiqu√©.

Voici comment d√©finir des sessions iBGP entre des routeurs situ√©s dans
le m√™me centre de donn√©es :

    ::jinja
    {% raw %}
    {% for neighbor in devices("location", "groups==edge") if neighbor != device %}
      {% for address in lookup("topology", "addresses", neighbor).loopback|tolist %}
    protocols bgp group IPV{{ address|ipv }}-EDGES-IBGP {
      neighbor {{ address }} {
        description "IPv{{ address|ipv }}: iBGP to {{ neighbor }}";
      }
    }
      {% endfor %}
    {% endfor %}
    {% endraw %}

Nous disposons √©galement d'une base de donn√©es cl√©-valeur pour
enregistrer les informations √† r√©utiliser dans un autre mod√®le ou
√©quipement. Ceci est tr√®s utile pour construire automatiquement des
enregistrement DNS. Tout d'abord, on ¬´¬†capture¬†¬ª l'adresse IP ins√©r√©e
dans un mod√®le avec le filtre `store()` :

    ::jinja
    {% raw %}
    interface Loopback0
     description 'Loopback:'
     {% for address in lookup('topology', 'addresses').loopback|tolist %}
     ipv{{ address|ipv }} address {{ address|store('addresses', 'Loopback0')|ipaddr('cidr') }}
     {% endfor %}
    !
    {% endraw %}

Puis, nous r√©utilisons les valeurs stock√©es pour construire les
enregistrements DNS en it√©rant sur les r√©sultats de la fonction
`store()`[^function] :

    ::jinja
    {% raw %}
    {% for device, ip, interface in store('addresses') %}
      {% set interface = interface|replace('/', '-')|replace('.', '-')|replace(':', '-') %}
      {% set name = '{}.{}'.format(interface|lower, device) %}
    {{ name }}. IN {{ 'A' if ip|ipv4 else 'AAAA' }} {{ ip|ipaddr('address') }}
    {% endfor %}
    {% endraw %}

[^function]: C'est un peu confus. Nous avons un filtre `store()` et
    une fonction `store()`. Dans *Jinja2*, les filtres et les
    fonctions vivent dans deux espaces de noms distincts.

Les mod√®les sont compil√©s localement avec `./run-jerikan build`.
L'argument `--limit` restreint les √©quipements pour lesquels g√©n√©rer
des configurations. La construction ne se fait pas en parall√®le car un
mod√®le peut d√©pendre des donn√©es collect√©es par un autre mod√®le.
Actuellement, il faut 1 minute pour construire environ 3000 fichiers
couvrant plus de 800 appareils.

![Sortie de Jerikan lors de la compilation des
mod√®les]([[!!images/jerikan/templates@2x.jpg]] "Sortie de Jerikan
apr√®s la g√©n√©ration des fichiers de configuration pour six
√©quipements")

Lorsqu'une erreur se produit, une trace d√©taill√©e est affich√©e. Elle
inclut le nom du mod√®le, le num√©ro de ligne et la valeur de toutes les
variables visibles. C'est un gain de temps consid√©rable par rapport √†
*Ansible* !

    ::text hl_lines="1 7 26"
    {% raw %}
    templates/opengear/config.j2:15: in top-level template code
        config.interfaces.{{ interface }}.netmask {{ adddress | ipaddr("netmask") }}
            continent  = 'us'
            device     = 'con1-ag2.ussfo03.blade-group.net'
            environment = 'prod'
            host       = 'con1-ag2.ussfo03'
            infos      = {'address': '172.30.24.19/21'}
            interface  = 'wan'
            location   = 'ussfo03'
            loop       = <LoopContext 1/2>
            member     = '2'
            model      = 'cm7132-2-dac'
            os         = 'opengear'
            shorthost  = 'con1-ag2'
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    
    value = JerkianUndefined, query = 'netmask', version = False, alias = 'ipaddr'
    
    [‚Ä¶]
            # Check if value is a list and parse each element
            if isinstance(value, (list, tuple, types.GeneratorType)):
                _ret = [ipaddr(element, str(query), version) for element in value]
                return [item for item in _ret if item]
    
    >       elif not value or value is True:
    E       jinja2.exceptions.UndefinedError: 'dict object' has no attribute 'adddress'
    {% endraw %}

Nous ne disposons pas de r√®gles g√©n√©rales pour l'√©criture des mod√®les.
Comme pour la source de v√©rit√©, il n'est pas n√©cessaire de cr√©er des
mod√®les g√©n√©riques capables de produire n'importe quelle configuration
BGP. Il y a un √©quilibre √† trouver entre la lisibilit√© et le fait
d'√©viter la duplication. Les mod√®les peuvent devenir effrayants et
complexes : parfois, il est pr√©f√©rable d'√©crire un filtre ou une
fonction dans [`jerikan/jinja.py`][jerikan/jinja.py]. Ma√Ætriser
[Jinja2][] est un tr√®s bon investissement. Prenez le temps de
parcourir [nos mod√®les][our templates], car certains d'entre eux
pr√©sentent des fonctionnalit√©s int√©ressantes.

## Validation

Optionellement, chaque fichier de configuration peut √™tre valid√© par
un script dans le r√©pertoire [`checks/`][checks]. *Jerikan* utilise la
variable `checks` dans l'espace de noms `build` pour conna√Ætre les
tests √† appliquer :

    ::console
    $ ./run-jerikan lookup edge1.ussfo03.blade-group.net build checks
    - description: Juniper configuration file syntax check
      script: checks/junoser
      cache:
        input: config.txt
        output: config-set.txt
    - description: check YAML data
      script: checks/data.yaml
      cache: data.yaml

Dans l'exemple ci-dessus, `checks/junoser` est ex√©cut√© s'il y a une
modification du fichier g√©n√©r√© `config.txt`. Il produit √©galement une
version transform√©e du fichier de configuration qui est plus facile √†
interfacer avec l'utilitaire `diff`. [Junoser][] v√©rifie un fichier de
configuration Junos en utilisant la d√©finition du sch√©ma XML pour
Netconf[^fork]. En cas d'erreur, *Jerikan* affiche :

    jerikan/build.py:127: RuntimeError
    -------------- Captured syntax check with Junoser call --------------
    P: checks/junoser edge2.ussfo03.blade-group.net
    C: /app/jerikan
    O:
    E: Invalid syntax:  set system syslog archive size 10m files 10 word-readable
    S: 1

[^fork]: Nous utilisons une [version modifi√©e][fork] pour pouvoir
    valider nos configurations et exposer un service HTTP pour r√©duire
    le temps de validation.

## Int√©gration continue avec GitLab

L'√©tape suivante consiste √† compiler les mod√®les en utilisant un
syst√®me d'int√©gration continue. Comme nous utilisons GitLab, *Jerikan*
contient avec un fichier [`.gitlab-ci.yml`][gitlab-ci.yml]. Lorsque
nous devons effectuer un changement, nous cr√©ons une branche d√©di√©e et
une demande de fusion. GitLab compile les mod√®les en utilisant le m√™me
environnement que celui que nous utilisons sur nos ordinateurs
portables et les stocke dans un artefact.

![Demande de fusion dans
GitLab]([[!!images/jerikan/merge-request@2x.png]] "Demande de fusion
pour ajouter un nouveau port sur USSFO03. Les mod√®les sont compil√©s
avec succ√®s mais un autre membre de l'√©quipe doit approuver le
changement avant de pouvoir l'int√©grer.")

Avant d'approuver une fusion, un autre membre de l'√©quipe √©tudie les
changements au niveau du code mais aussi les diff√©rences au niveau des
fichiers g√©n√©r√©s :

![Diff√©rences sur les fichiers
g√©n√©r√©s]([[!!images/jerikan/diff@2x.png]] "Le changement inclut la
configuration d'un port sur un √©quipement Juniper, l'ajout des
enregistrements DNS et les mises √† jour de NetBox pour les nouvelles
adresses IP.")

# Ansible

Une fois que *Jerikan* a construit les fichiers de configuration,
*Ansible* prend le relais. Il est √©galement livr√© sous la forme d'une
image Docker pour √©viter la maintenance d'un environnement virtuel
Python et s'assurer que nous utilisons tous les m√™mes versions.

## Inventaire

*Jerikan* a g√©n√©r√© un fichier d'inventaire. Il contient tous les
√©quipements g√©r√©s, des variables d√©finies pour chacun d'eux et les
groupes convertis en groupes *Ansible* :

    ::toml
    ob1-n1.sk1.blade-group.net ansible_host=172.29.15.12 ansible_user=blade ansible_connection=network_cli ansible_network_os=ios
    ob2-n1.sk1.blade-group.net ansible_host=172.29.15.13 ansible_user=blade ansible_connection=network_cli ansible_network_os=ios
    ob1-n1.ussfo03.blade-group.net ansible_host=172.29.15.12 ansible_user=blade ansible_connection=network_cli ansible_network_os=ios
    none ansible_connection=local
    
    [oob]
    ob1-n1.sk1.blade-group.net
    ob2-n1.sk1.blade-group.net
    ob1-n1.ussfo03.blade-group.net
    
    [os-ios]
    ob1-n1.sk1.blade-group.net
    ob2-n1.sk1.blade-group.net
    ob1-n1.ussfo03.blade-group.net
    
    [model-c2960s]
    ob1-n1.sk1.blade-group.net
    ob2-n1.sk1.blade-group.net
    ob1-n1.ussfo03.blade-group.net
    
    [location-sk1]
    ob1-n1.sk1.blade-group.net
    ob2-n1.sk1.blade-group.net
    
    [location-ussfo03]
    ob1-n1.ussfo03.blade-group.net

    [in-sync]
    ob1-n1.sk1.blade-group.net
    ob2-n1.sk1.blade-group.net
    ob1-n1.ussfo03.blade-group.net
    none

`in-sync` est un groupe sp√©cial pour les √©quipements dont la
configuration doit correspondre √† la configuration g√©n√©r√©e.
Quotidiennement et sans surveillance, *Ansible* devrait √™tre capable
de pousser les configurations vers ce groupe. L'objectif √† moyen terme
est de couvrir tous les √©quipements.

`none` est un √©quipement sp√©cial pour les t√¢ches non li√©es √† un h√¥te
sp√©cifique. Cela inclut la [synchronisation de NetBox][synchronizing
NetBox], des [objets IRR][IRR objects] et du DNS, la mise √† jour de la
RPKI et la construction des fichiers de g√©olocalisation.

## Playbook

Nous utilisons un unique *playbook* pour tous les √©quipements. Il est
d√©crit dans le fichier
[`ansible/playbooks/site.yaml`][ansible/playbooks/site.yaml]. En voici
une version raccourcie :

    ::yaml
    - hosts: adm-gateway:!done
      strategy: mitogen_linear
      roles:
        - blade.linux
        - blade.adm-gateway
        - done
    
    - hosts: os-linux:!done
      strategy: mitogen_linear
      roles:
        - blade.linux
        - done
    
    - hosts: os-junos:!done
      gather_facts: false
      roles:
        - blade.junos
        - done
    
    - hosts: os-opengear:!done
      gather_facts: false
      roles:
        - blade.opengear
        - done
    
    - hosts: none:!done
      gather_facts: false
      roles:
        - blade.none
        - done

Un h√¥te n'ex√©cute qu'un seul des r√¥les. Par exemple, un √©quipement
Junos ex√©cute le r√¥le `blade.junos`. Une fois qu'un r√¥le a √©t√©
ex√©cut√©, l'√©quipement est ajout√© au groupe `done` et les autres r√¥les
sont ignor√©s.

Le playbook peut √™tre ex√©cut√© avec les fichiers de configuration
g√©n√©r√©s par GitLab en utilisant la commande `./run-ansible-gitlab`.
Elle utilise Docker pour exposer la commande `ansible-playbook` et
elle accepte les m√™mes arguments. Pour simuler un d√©ploiement de la
configuration sur les √©quipements du centre de donn√©es SK1, nous
utilisons :

    ::console
    $ ./run-ansible-gitlab playbooks/site.yaml --limit='edge:&location-sk1' --diff --check
    [‚Ä¶]
    PLAY RECAP *************************************************************
    edge1.sk1.blade-group.net  : ok=6    changed=0    unreachable=0    failed=0    skipped=3    rescued=0    ignored=0
    edge2.sk1.blade-group.net  : ok=5    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0

Nous avons quelques r√®gles pour √©crire les r√¥les :

 - `--check` doit d√©tecter si un changement est n√©cessaire,
 - `--diff` doit fournir une visualisation des changements pr√©vus,
 - `--check` et `--diff` ne doivent rien afficher s'il n'y a rien √† changer,
 - [√©crire un module sur mesure][writing a custom module] pour nos besoins est une solution valable,
 - toute la configuration de l'√©quipement est g√©r√©e[^derivation],
 - les secrets doivent √™tre stock√©s dans *Vault*,
 - les mod√®les doivent √™tre √©vit√©s car nous avons *Jerikan* pour cela,
 - les t√¢ches doivent √™tre r√©utilis√©es et non dupliqu√©es[^duplication].

[^derivation]: Il y a une tendance dans l'automatisation des r√©seaux √†
    se limiter √† un sous-ensemble de configuration, par exemple en
    ayant un playbook pour cr√©er une nouvelle session BGP. Nous
    pensons que c'est une mauvaise approche : avec le temps, votre
    configuration ne correspondra pas √† l'√©tat attendu, notamment les
    changements faits √† la main ne seront pas d√©tect√©s.

[^duplication]: Voir
    [`ansible/roles/blade.linux/tasks/firewall.yaml`][firewall.yaml]
    et
    [`ansible/roles/blade.linux/tasks/interfaces.yaml`][interfaces.yaml].
    Ils sont destin√©s √† √™tre appel√©s lorsque cela est n√©cessaire, en
    utilisant `import_role`.

Nous √©vitons d'utiliser des collections d'[Ansible Galaxy][], √†
l'exception de celles permettant de se connecter et d'interagir avec
les √©quipements constructeur, comme la [collection
`cisco.iosxr`][cisco.iosxr]. La qualit√© des collections d'*Ansible
Galaxy* est assez al√©atoire et cela repr√©sente un effort de
maintenance suppl√©mentaire. Nous pr√©f√©rons √©crire des r√¥les adapt√©s √†
nos besoins. Les collections que nous utilisons sont dans
[`ci/ansible/ansible-galaxy.yaml`][ansible-galaxy.yaml]. Nous
utilisons [Mitogen][] pour acc√©l√©rer consid√©rablement les ex√©cutions
d'*Ansible* sur les h√¥tes Linux.

Nous disposons √©galement de quelques playbooks √† des fins
op√©rationnelles : mise √† niveau d'une version, isolation d'un routeur
Internet, etc. Nous avions √©galement en t√™te d'ajouter une √©tape de
validation dans les r√¥les : est-ce que toutes les sessions BGP sont
op√©rationnelles ? Cela aurait permis de valider un d√©ploiement et de
revenir rapidement en arri√®re en cas de probl√®mes.

Actuellement, nos playbooks sont ex√©cut√©s √† partir de nos ordinateurs
portables. Pour assurer le suivi des ex√©cutions, nous utilisons
[ARA][]. Un essai hebdomadaire sur les √©quipements du groupe `in-sync`
fournit √©galement un tableau de bord sur les h√¥tes sur lesquels nous
devons faire converger la configuration.

# Donn√©es de configuration et mod√®les

Nous livrons *Jerikan* avec des donn√©es et des mod√®les correspondant √†
la configuration de nos centres de donn√©es USSFO03 et SK1. Ils
n'existent plus mais, nous vous le promettons, tout ceci √©tait utilis√©
en production √† une √©poque ! üò¢

![Architecture r√©seau pour les centres de donn√©es
Blade]([[!!images/jerikan/network@2x.png]] "La derni√®re it√©ration de
notre infrastructure r√©seau pour SK1, USSFO03 et les futurs centres de
donn√©es. Le r√©seau de production utilise BGPttH en utilisant une
topologie Clos. Le r√©seau hors bande utilise une conception L2 simple,
avec le protocole STP, ainsi qu'un ensemble de serveurs de console.")

Vous trouverez la configuration pour :

nos routeurs Internet
: Certains fonctionnent sur *Junos*, comme [edge2.ussfo03][], les
  autres sur IOS-XR, comme [edge1.sk1][]. Les fonctionnalit√©s
  impl√©ment√©es sont similaires dans les deux cas et nous pouvons
  √©changer l'un contre l'autre. Il y a la configuration BGP pour les
  transits, les peerings et les IX ainsi que les politiques BGP
  associ√©es. [PeeringDB][] est interrog√© pour obtenir le nombre
  maximum de pr√©fixes √† accepter. [bgpq3 et un IRRd
  conteneuris√©][bgpq3 and a containerized IRRd] aident √† filtrer les
  routes re√ßues. Un pare-feu est √©galement pr√©sent. IPv4 et IPv6 sont
  tous deux configur√©s.

notre fabrique BGP
: BGP est utilis√© √† l'int√©rieur du centre de donn√©es[^evpn] et s'√©tend
  jusqu'aux les h√¥tes physiques. La configuration est automatiquement
  d√©riv√©e de l'emplacement du dispositif et du num√©ro de
  port[^bgptth]. Les switchs en haut de chaque rack utilisent des
  sessions BGP passives pour les ports vers les serveurs. Ils exposent
  √©galement un r√©seau sp√©cifique pour permettre de d√©marrer en
  utilisant DHCP et PXE. Ils font √©galement office de serveur DHCP. La
  conception est multivendeur : certains √©quipements fonctionnent sous
  *Cumulus Linux*, comme [to1-p1.ussfo03][], tandis que d'autres
  fonctionnent sous *Junos*, comme [to1-p2.ussfo03][].

notre r√©seau hors bande
: Nous utilisons des commutateurs Cisco Catalyst 2960 pour construire
  un r√©seau hors bande L2. Pour assurer la redondance et √©conomiser
  quelques sous sur le c√¢blage, nous construisons des petites boucles
  et exploitons le protocole STP. Regardez [ob1-p1.ussfo03][]. Le
  r√©seau est connect√© de mani√®re redondante √† des serveurs d'acc√®s.
  Nous utilisons √©galement des √©quipements OpenGear pour les acc√®s
  console. Regardez [con1-n1.ussfo03][].

nos passerelles d'acc√®s
: Ces serveurs Linux ont plusieurs objectifs : passerelles SSH,
  connexion de secours, acc√®s direct au r√©seau hors bande,
  installation automatis√©e des √©quipements r√©seau[^ztp], acc√®s
  Internet pour les flux administratifs, centralisation des serveurs
  de console √† l'aide de [Conserver][] et mise √† disposition d'une API
  pour l'autoconfiguration des sessions BGP pour les serveurs
  physiques. Ce sont les premiers serveurs install√©s dans un nouveau
  centre de donn√©es et ils sont utilis√©s pour mettre en place tout le
  reste. Regardez √† la fois les [fichiers g√©n√©r√©s][generated files] et
  les [t√¢ches Ansible][Ansible tasks] associ√©es.

[^evpn]: Nous avons √©galement quelques centres de donn√©es qui
    utilisent BGP EVPN VXLAN avec des √©quipements *Juniper*. Comme ils
    sont encore en production aujourd'hui, nous n'avons pas inclus
    cette fonctionnalit√© mais nous pourrions la publier √† l'avenir.

[^bgptth]: R√©trospectivement, ce n'est peut-√™tre pas une bonne id√©e,
    sauf si vous √™tes √† peu pr√®s s√ªr que tout est immuable. Ce n'√©tait
    pas notre cas. Nous pensons maintenant qu'il aurait √©t√© plus
    judicieux d'attribuer un pr√©fixe √† chaque appareil et de le
    consigner dans la source de v√©rit√©.

[^ztp]: Les √©quipements n'utilisant pas Linux sont mis √† jour et
    configur√©s sans interaction de notre part. Les p√©riph√©riques
    *Cumulus Linux* sont automatiquement mis √† jour lors de leur
    premi√®re installation mais la configuration finale doit √™tre
    pouss√©e en utilisant *Ansible* : nous ne voulions pas dupliquer le
    processus de configuration en utilisant un autre outil.

*[IRRs]: Internet Routing Registries
*[IRR]: Internet Routing Registry
*[STP]: Spanning Tree Protocol
*[RPKI]: Resource Public Key Infrastructure
*[IX]: Internet Exchange

[C√©dric Hasco√´t]: https://www.linkedin.com/in/c%C3%A9dric-hasco%C3%ABt-5069087b/
[Jean-Christophe Legatte]: https://www.linkedin.com/in/jean-christophe-legatte-b9b86298/
[Lo√Øc Pailhas]: https://www.linkedin.com/in/lo%C3%AFc-pailhas-b40893136/
[S√©bastien Hurtel]: https://www.linkedin.com/in/s%C3%A9bastien-hurtel-14a501140/
[Tchadel Icard]: https://twitter.com/tchadelicard/
[Vincent Bernat]: [[fr]]
[Shadow]: https://shadow.tech
[OVHcloud]: https://www.ovh.com
[was bought by Octave Klaba]: https://www.nextinpact.com/article/43500/reprise-blade-octave-klaba-emporte "Reprise de Blade (Shadow) : Octave Klaba l'emporte"
[Ansible]: https://www.ansible.com "https://www.ansible.com"
[first steps]: https://docs.ansible.com/ansible/latest/network/index.html "Ansible for Network Automation"
[narrow scope]: https://gitlab.com/cumulus-consulting/goldenturtle/cumulus_ansible_modules "NVIDIA Cumulus Linux Roles"
[Puppet]: https://github.com/wikimedia/puppet "Puppet repository for the Wikimedia Foundation"
[Jerikan]: https://github.com/jerikan-network/cmdb
[SaltStack]: https://github.com/creativecommons/sre-salt-prime "Creative Commons SaltStack configuration files"
[rigid]: https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#understanding-variable-precedence "Using Variables: Understanding variable precedence"
[BGP YANG model]: https://github.com/openconfig/public/tree/master/release/models/bgp "OpenConfig's YANG model for BGP"
[devices.yaml]: https://github.com/jerikan-network/cmdb/blob/main/devices.yaml
[classifier.yaml]: https://github.com/jerikan-network/cmdb/blob/main/classifier.yaml
[docker-compose.yaml]: https://github.com/jerikan-network/cmdb/blob/main/docker-compose.yaml
[gitlab-ci.yml]: https://github.com/jerikan-network/cmdb/blob/main/.gitlab-ci.yml
[schema.yaml]: https://github.com/jerikan-network/cmdb/blob/main/schema.yaml
[searchpaths.py]: https://github.com/jerikan-network/cmdb/blob/main/searchpaths.py
[data]: https://github.com/jerikan-network/cmdb/tree/main/data
[Jinja2]: https://jinja.palletsprojects.com/en/2.11.x/templates/ "Jinja2: moteur de mod√®les pour Python"
[ipaddr]: https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters_ipaddr.html "Ansible: ipaddr filter"
[templates/junos/base.j2]: https://github.com/jerikan-network/cmdb/blob/main/templates/junos/base.j2
[our templates]: https://github.com/jerikan-network/cmdb/tree/main/templates
[jerikan/jinja.py]: https://github.com/jerikan-network/cmdb/blob/main/jerikan/jinja.py
[checks]: https://github.com/jerikan-network/cmdb/tree/main/checks
[Junoser]: https://github.com/codeout/junoser/ "PEG parser for Junos configuration"
[fork]: https://github.com/jerikan-network/junoser "Junoser fork"
[Docker Compose]: https://docs.docker.com/compose/ "Overview of Docker Compose"
[Docker]: https://docs.docker.com/ "Docker documentation"
[Hiera]: https://puppet.com/docs/puppet/latest/hiera_intro.html
[Jerakia]: http://jerakia.io/ "Jerakia: a versatile data lookup system"
[Python function]: https://github.com/jerikan-network/cmdb/blob/main/jerikan/jerakia.py
[synchronizing NetBox]: [[fr/blog/2020-synchro-netbox-ansible.html]] "Synchroniser NetBox avec un module Ansible sur mesure"
[IRR objects]: [[fr/blog/2020-synchro-ripe-arin-apnic-ansible.html]] "Synchroniser des objets RIPE, ARIN et APNIC avec un module Ansible sur mesure"
[ansible/playbooks/site.yaml]: https://github.com/jerikan-network/cmdb/blob/main/ansible/playbooks/site.yaml
[cisco.iosxr]: https://galaxy.ansible.com/cisco/iosxr "Ansible Galaxy: cisco.iosxr collection"
[Ansible Galaxy]: https://galaxy.ansible.com "Ansible Galaxy"
[ansible-galaxy.yaml]: https://github.com/jerikan-network/cmdb/blob/main/ci/ansible/ansible-galaxy.yaml
[Mitogen]: https://mitogen.networkgenomics.com/ansible_detailed.html "Mitogen for Ansible"
[writing a custom module]: [[fr/blog/2020-ecrire-module-ansible.html]] "√âcrire un module Ansible sur mesure"
[firewall.yaml]: https://github.com/jerikan-network/cmdb/blob/main/ansible/roles/blade.linux/tasks/firewall.yaml
[interfaces.yaml]: https://github.com/jerikan-network/cmdb/blob/main/ansible/roles/blade.linux/tasks/interfaces.yaml
[edge1.sk1]: https://github.com/jerikan-network/cmdb/blob/generated-public/output/edge1.sk1.blade-group.net/config.txt
[edge2.ussfo03]: https://github.com/jerikan-network/cmdb/blob/generated-public/output/edge2.ussfo03.blade-group.net/config.txt
[to1-p1.ussfo03]: https://github.com/jerikan-network/cmdb/tree/generated-public/output/to1-p1.ussfo03.blade-group.net
[to1-p2.ussfo03]: https://github.com/jerikan-network/cmdb/blob/generated-public/output/to1-p2.ussfo03.blade-group.net/config.txt
[ob1-p1.ussfo03]: https://github.com/jerikan-network/cmdb/blob/generated-public/output/ob1-p1.ussfo03.blade-group.net/config.txt
[con1-n1.ussfo03]: https://github.com/jerikan-network/cmdb/blob/generated-public/output/con1-n1.ussfo03.blade-group.net/config.txt
[PeeringDB]: https://www.peeringdb.com/ "The Interconnection Database"
[bgpq3 and a containerized IRRd]: [[fr/blog/2020-bgpq4-irrd-docker.html]] "Acc√©l√©rer bgpq4 avec IRRd dans un containeur"
[Conserver]: https://www.conserver.com/
[generated files]: https://github.com/jerikan-network/cmdb/tree/generated-public/output/gateway1.ussfo03.blade-group.net
[Ansible tasks]: https://github.com/jerikan-network/cmdb/tree/main/ansible/roles/blade.adm-gateway/tasks
[ARA]: https://ara.recordsansible.org "ARA Records Ansible"
