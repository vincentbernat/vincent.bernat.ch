---
title: "Encodage rapide et dynamique des Protocol Buffers en Go"
description: |
   L'encodage vers les Protocol Buffers n√©cessite habituellement un fichier de
   d√©finition. Cependant, avec un sch√©ma d√©fini par le code et l'utilisation
   des primitives de bas niveau, il est possible de conserver de bonnes performances.
uuid: df4283b6-60f1-4434-9cc1-986c618855ef
tags:
  - programming-go
  - project-akvorado
---

Les [Protocol Buffers][] sont un choix populaire pour la **s√©rialisation de donn√©es
structur√©es** en raison de leur taille compacte, de leur rapidit√© de traitement,
de leur ind√©pendance du langage cible et de leur compatibilit√©. D'autres
alternatives existent, notamment [Cap'n Proto][], [CBOR][] et [Avro][].

Les structures de donn√©es sont habituellement d√©crites dans un **fichier de
d√©finition de protocole** (`.proto`). Le compilateur `protoc` et un greffon
sp√©cifique √† un langage les convertissent en code:

```console
$ head flow-4.proto
syntax = "proto3";
package decoder;
option go_package = "akvorado/inlet/flow/decoder";

message FlowMessagev4 {

  uint64 TimeReceived = 2;
  uint32 SequenceNum = 3;
  uint64 SamplingRate = 4;
  uint32 FlowDirection = 5;
$ protoc -I=. --plugin=protoc-gen-go --go_out=module=akvorado:. flow-4.proto
$ head inlet/flow/decoder/flow-4.pb.go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//      protoc-gen-go v1.28.0
//      protoc        v3.21.12
// source: inlet/flow/data/schemas/flow-4.proto

package decoder

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
```

[Akvorado][] collecte les flux r√©seau √† l'aide de [IPFIX][] ou [sFlow][], les
d√©code √† l'aide de [GoFlow2][], les encode en *Protocol Buffers* et les envoie √†
[Kafka][] pour les stocker dans une base de donn√©es [ClickHouse][]. La collecte
d'un nouveau champ, comme les adresses MAC source et destination, n√©cessite des
modifications √† plusieurs endroits, y compris le fichier de d√©finition de
protocole et le code de migration pour ClickHouse. De plus, le co√ªt est support√©
par tous les utilisateurs[^cost]. Il serait agr√©able d'avoir un **sch√©ma commun
√† l'application** et de permettre aux utilisateurs d'activer ou de d√©sactiver
les champs dont ils ont besoin.

[^cost]: Bien que les champs vides ne sont pas s√©rialis√©s en *Protocol Buffers*,
    les colonnes vides dans *ClickHouse* occupent de la place, m√™me si
    elles se compressent bien. De plus, les champs inutilis√©s sont toujours
    d√©cod√©s et peuvent encombrer l'interface.

Bien que le principal objectif est la flexibilit√©, nous ne voulons pas sacrifier
les performances. Sur ce front, c'est un v√©ritable succ√®s: lors de la mise √†
niveau de 1.6.4 √† 1.7.1, les performances de d√©codage et d'encodage ont presque
doubl√© ! ü§ó

```text
goos: linux
goarch: amd64
pkg: akvorado/inlet/flow
cpu: AMD Ryzen 5 5600X 6-Core Processor
                            ‚îÇ initial.txt  ‚îÇ              final.txt              ‚îÇ
                            ‚îÇ    sec/op    ‚îÇ   sec/op     vs base                ‚îÇ
Netflow/with_encoding-12      12.963¬µ ¬± 2%   7.836¬µ ¬± 1%  -39.55% (p=0.000 n=10)
Sflow/with_encoding-12         19.37¬µ ¬± 1%   10.15¬µ ¬± 2%  -47.63% (p=0.000 n=10)
```

# Encodage plus rapide des Protocol Buffers

J'utilise le [code suivant][bench-initial] pour mesurer les performances du
processus de d√©codage et d'encodage. Initialement, la m√©thode `Decode()` est une
simple fa√ßade au-dessus du producteur _GoFlow2_. Elle stocke les donn√©es
d√©cod√©es dans la structure en m√©moire g√©n√©r√©e par `protoc`. Par la suite,
certaines donn√©es seront encod√©es directement pendant le d√©codage des flux.
C'est pourquoi nous mesurons √† la fois le d√©codage et l'encodage[^netflow].

```go
func BenchmarkDecodeEncodeSflow(b *testing.B) {
    r := reporter.NewMock(b)
    sdecoder := sflow.New(r)
    data := helpers.ReadPcapPayload(b,
        filepath.Join("decoder", "sflow", "testdata", "data-1140.pcap"))

    for _, withEncoding := range []bool{true, false} {
        title := map[bool]string{
            true:  "with encoding",
            false: "without encoding",
        }[withEncoding]
        var got []*decoder.FlowMessage
        b.Run(title, func(b *testing.B) {
            for i := 0; i < b.N; i++ {
                got = sdecoder.Decode(decoder.RawFlow{
                    Payload: data,
                    Source: net.ParseIP("127.0.0.1"),
                })
                if withEncoding {
                    for _, flow := range got {
                        buf := []byte{}
                        buf = protowire.AppendVarint(buf, uint64(proto.Size(flow)))
                        proto.MarshalOptions{}.MarshalAppend(buf, flow)
                    }
                }
            }
        })
    }
}
```



[^netflow]: Il existe une fonction similaire pour *NetFlow*. Les protocoles
    NetFlow et IPFIX sont moins complexes √† d√©coder que sFlow car ils utilisent
    une structure TLV plus simple.

L'impl√©mentation Go de r√©f√©rence pour les *Protocol Buffers*,
[`google.golang.org/protobuf`][google.golang.org/protobuf] n'est pas la plus
efficace. Pendant longtemps, l'alternative la plus courante √©tait
[gogoprotobuf][]. Cependant, le projet est maintenant [obsol√®te][deprecated].
[vtprotobuf][] est un bon remplacement[^vtprotobuf].

```text
goos: linux
goarch: amd64
pkg: akvorado/inlet/flow
cpu: AMD Ryzen 5 5600X 6-Core Processor
                            ‚îÇ initial.txt ‚îÇ             bench-2.txt             ‚îÇ
                            ‚îÇ   sec/op    ‚îÇ   sec/op     vs base                ‚îÇ
Netflow/with_encoding-12      12.96¬µ ¬± 2%   10.28¬µ ¬± 2%  -20.67% (p=0.000 n=10)
Netflow/without_encoding-12   8.935¬µ ¬± 2%   8.975¬µ ¬± 2%        ~ (p=0.143 n=10)
Sflow/with_encoding-12        19.37¬µ ¬± 1%   16.67¬µ ¬± 2%  -13.93% (p=0.000 n=10)
Sflow/without_encoding-12     14.62¬µ ¬± 3%   14.87¬µ ¬± 1%   +1.66% (p=0.007 n=10)
```

[^vtprotobuf]: `vtprotobuf` g√©n√®re un code mieux optimis√© en supprimant un
    niveau d'indirection. Il produit du code codant chaque champ en octets :
    
        ::go
        if m.OutIfSpeed != 0 {
            i = encodeVarint(dAtA, i, uint64(m.OutIfSpeed))
            i--
            dAtA[i] = 0x6
            i--
            dAtA[i] = 0xd8
        }

# Encodage dynamique des Protocol Buffers

Nous avons d√©sormais une bonne r√©f√©rence d√©part. Voyons comment encoder nos
*Protocol Buffers* sans un fichier `.proto`. Le format utilis√© est relativement
simple et repose beaucoup sur les entiers √† longueur variable.

Les entiers √† longueur variable sont un moyen efficace d'encoder des entiers non
sign√©s en utilisant un nombre variable d'octets, de un √† dix, les petites
valeurs utilisant moins d'octets. Ils fonctionnent en scindant les entiers par
groupe de 7 bits et en utilisant le 8<sup>√®me</sup> bit comme signal de
continuation : il est mis √† 1 pour tous les groupes sauf le dernier.

![Encodage des entiers √† longueur variable dans les Protocol Buffers : conversion de 150]([[!!images/protobuf-varint.svg]]
"Encodage des entiers √† longueur variable")

Pour notre utilisation, nous avons besoin de deux types seulement : les entiers
√† longueur variable et les s√©quences d'octets. Une s√©quence d'octets est cod√©e en
la pr√©fixant par sa longueur sous forme d'entier √† longueur variable. Lorsqu'un
message est cod√©, chaque couple cl√©-valeur est transform√© en un enregistrement
compos√© d'un num√©ro de champ, d'un type et de la valeur. Le num√©ro de champ et
le type sont cod√©s en un seul entier de longueur variable appel√© ¬´¬†*tag*¬†¬ª.

![Message cod√© avec les Protocol Buffers : 3 entiers et 2 s√©quences d'octets]([[!!images/protobuf-message.svg]]
"Message cod√© avec les Protocol Buffers")

Nous utilisons les fonctions bas niveau suivantes pour construire le message
cod√© :

- [`protowire.AppendTag()`][protowire.AppendTag] code un ¬´¬†*tag*¬†¬ª,
- [`protowire.AppendVarint()`][protowire.AppendVarint] code un entier,
- [`protowire.AppendBytes()`][protowire.AppendBytes] ajoute des octets sans modification.

Notre abstraction pour le sch√©ma contient les informations appropri√©es pour
coder un message (`ProtobufIndex`) et pour g√©n√©rer un fichier de d√©finition de
protocole (les champs commen√ßant par `Protobuf`) :

```go
type Column struct {
    Key       ColumnKey
    Name      string
    Disabled  bool

    // [‚Ä¶]
    // For protobuf.
    ProtobufIndex    protowire.Number
    ProtobufType     protoreflect.Kind // Uint64Kind, Uint32Kind, ‚Ä¶
    ProtobufEnum     map[int]string
    ProtobufEnumName string
    ProtobufRepeated bool
}
```

Nous avons quelques [m√©thodes simples][helper methods] autour des fonctions
`protowire` pour encoder directement les champs lors du d√©codage des flux. Ils
sautent les champs d√©sactiv√©s ou ceux d√©j√† encod√©s mais non r√©p√©tables. Voici un
extrait du [d√©codeur sFlow][sFlow decoder]:

```go
sch.ProtobufAppendVarint(bf, schema.ColumnBytes, uint64(recordData.Base.Length))
sch.ProtobufAppendVarint(bf, schema.ColumnProto, uint64(recordData.Base.Protocol))
sch.ProtobufAppendVarint(bf, schema.ColumnSrcPort, uint64(recordData.Base.SrcPort))
sch.ProtobufAppendVarint(bf, schema.ColumnDstPort, uint64(recordData.Base.DstPort))
sch.ProtobufAppendVarint(bf, schema.ColumnEType, helpers.ETypeIPv4)
```

Les champs n√©cessaires dans la suite du traitement, comme les adresses source et
destination, sont stock√©s non cod√©s dans une structure s√©par√©e :

```go
type FlowMessage struct {
    TimeReceived uint64
    SamplingRate uint32

    // For exporter classifier
    ExporterAddress netip.Addr

    // For interface classifier
    InIf  uint32
    OutIf uint32

    // For geolocation or BMP
    SrcAddr netip.Addr
    DstAddr netip.Addr
    NextHop netip.Addr

    // Core component may override them
    SrcAS     uint32
    DstAS     uint32
    GotASPath bool

    // protobuf is the protobuf representation for the information not contained above.
    protobuf      []byte
    protobufSet   bitset.BitSet
}
```

Le tableau `protobuf` contient les donn√©es encod√©es. Il est initialis√© avec une
capacit√© de 500 octets pour √©viter les redimensionnements pendant l'encodage. Il
y a √©galement quelques octets r√©serv√©s au d√©but pour pouvoir encoder la taille
totale en tant qu'entier de longueur variable. Lors de la finalisation de
l'encodage, les champs restants sont ajout√©s et la longueur du message est
ins√©r√©e dans l'espace libre au d√©but :

```go
func (schema *Schema) ProtobufMarshal(bf *FlowMessage) []byte {
    schema.ProtobufAppendVarint(bf, ColumnTimeReceived, bf.TimeReceived)
    schema.ProtobufAppendVarint(bf, ColumnSamplingRate, uint64(bf.SamplingRate))
    schema.ProtobufAppendIP(bf, ColumnExporterAddress, bf.ExporterAddress)
    schema.ProtobufAppendVarint(bf, ColumnSrcAS, uint64(bf.SrcAS))
    schema.ProtobufAppendVarint(bf, ColumnDstAS, uint64(bf.DstAS))
    schema.ProtobufAppendIP(bf, ColumnSrcAddr, bf.SrcAddr)
    schema.ProtobufAppendIP(bf, ColumnDstAddr, bf.DstAddr)

    // Add length and move it as a prefix
    end := len(bf.protobuf)
    payloadLen := end - maxSizeVarint
    bf.protobuf = protowire.AppendVarint(bf.protobuf, uint64(payloadLen))
    sizeLen := len(bf.protobuf) - end
    result := bf.protobuf[maxSizeVarint-sizeLen : end]
    copy(result, bf.protobuf[end:end+sizeLen])

    return result
}
```

Minimiser les allocations est essentiel pour maintenir de bonnes performances.
Les tests doivent √™tre ex√©cut√©s avec le drapeau `-benchmem` pour surveiller le
nombre d'allocations : chacune entra√Æne un co√ªt indirect pour le ramasse-miette.
Le [profileur Go][Go profiler] est un outil pr√©cieux pour identifier les zones
du code qui peuvent √™tre optimis√©es :

```console
$ go test -run=__nothing__ -bench=Netflow/with_encoding \
>         -benchmem -cpuprofile profile.out \
>         akvorado/inlet/flow
goos: linux
goarch: amd64
pkg: akvorado/inlet/flow
cpu: AMD Ryzen 5 5600X 6-Core Processor
Netflow/with_encoding-12             143953              7955 ns/op            8256 B/op        134 allocs/op
PASS
ok      akvorado/inlet/flow     1.418s
$ go tool pprof profile.out
File: flow.test
Type: cpu
Time: Feb 4, 2023 at 8:12pm (CET)
Duration: 1.41s, Total samples = 2.08s (147.96%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) web
```

Apr√®s avoir [utilis√© le sch√©ma interne][conversion] au lieu du code g√©n√©r√© √†
partir du fichier de d√©finition, les performances se sont am√©lior√©es. Cependant,
cette comparaison n'est pas tout √† fait √©quitable car moins d'informations sont
d√©cod√©es et, auparavant, _GoFlow2_ d√©codait les flux vers sa propre structure
qui √©tait ensuite copi√©e dans notre version.

```text
goos: linux
goarch: amd64
pkg: akvorado/inlet/flow
cpu: AMD Ryzen 5 5600X 6-Core Processor
                            ‚îÇ bench-2.txt  ‚îÇ             bench-3.txt             ‚îÇ
                            ‚îÇ    sec/op    ‚îÇ   sec/op     vs base                ‚îÇ
Netflow/with_encoding-12      10.284¬µ ¬± 2%   7.758¬µ ¬± 3%  -24.56% (p=0.000 n=10)
Netflow/without_encoding-12    8.975¬µ ¬± 2%   7.304¬µ ¬± 2%  -18.61% (p=0.000 n=10)
Sflow/with_encoding-12         16.67¬µ ¬± 2%   14.26¬µ ¬± 1%  -14.50% (p=0.000 n=10)
Sflow/without_encoding-12      14.87¬µ ¬± 1%   13.56¬µ ¬± 2%   -8.80% (p=0.000 n=10)
```

Concernant les tests, nous utilisons
[`github.com/jhump/protoreflect`][protoreflect] : le paquet `protoparse` analyse
le fichier de d√©finition que nous avons construit dynamiquement et le paquet
`dynamic` d√©code les messages. Jetez un ≈ìil √† la m√©thode [`ProtobufDecode()`
method][protobufdecode] pour plus de d√©tails[^protoprint].

[^protoprint]: Il existe √©galement un paquet `protoprint` pour g√©n√©rer le
    fichier de d√©finition. Je ne l'ai pas utilis√©.

Pour obtenir les chiffres finaux, j'ai aussi optimis√© le d√©codage dans
_GoFlow2_. Il s'appuyait fortement sur [`binary.Read()`][binary.Read]. Cette
fonction peut utiliser la r√©flexion dans certains cas et chaque appel alloue un
tableau d'octets pour lire les donn√©es. [En la rempla√ßant par une version plus
efficace][pr141], on obtient encore une am√©lioration notable des performances :

```text
goos: linux
goarch: amd64
pkg: akvorado/inlet/flow
cpu: AMD Ryzen 5 5600X 6-Core Processor
                            ‚îÇ bench-3.txt  ‚îÇ             bench-4.txt             ‚îÇ
                            ‚îÇ    sec/op    ‚îÇ   sec/op     vs base                ‚îÇ
Netflow/with_encoding-12       7.758¬µ ¬± 3%   7.365¬µ ¬± 2%   -5.07% (p=0.000 n=10)
Netflow/without_encoding-12    7.304¬µ ¬± 2%   6.931¬µ ¬± 3%   -5.11% (p=0.000 n=10)
Sflow/with_encoding-12        14.256¬µ ¬± 1%   9.834¬µ ¬± 2%  -31.02% (p=0.000 n=10)
Sflow/without_encoding-12     13.559¬µ ¬± 2%   9.353¬µ ¬± 2%  -31.02% (p=0.000 n=10)
```

Il est maintenant plus facile de collecter de [nouvelles donn√©es][new data] et
le composant recevant les flux est d√©sormais plus rapide ! üöÖ

!!! "Note" La plupart des paragraphes ont √©t√© traduits de l'anglais par
[ChatGPT][] en utilisant les instructions suivantes : <span lang="en">‚ÄúFrom now
on, I will paste Markdown code in English and I would like you to translate it
to French. Keep the markdown markup and enclose the result into a code block.
Thanks.‚Äù</span> Le r√©sultat a √©t√© l√©g√®rement √©dit√© si n√©cessaire. Compar√© √†
[DeepL][], *ChatGPT* est capable de conserver le formatage, les anglicismes,
mais son fran√ßais est moins bon et il est n√©cessaire de lui rappeler
r√©guli√®rement les instructions.

*[TLV]: Type-Length-Value

[protocol buffers]: https://developers.google.com/protocol-buffers/ "Protocol Buffers"
[cap'n proto]: https://capnproto.org/ "Cap'n Proto"
[avro]: https://avro.apache.org/ "Apache Avro"
[akvorado]: [[fr/blog/2022-akvorado-collecteur-flux.html]] "Akvorado : collecteur et visualisateur de flux r√©seau"
[ipfix]: rfc://7011 "RFC 7011: Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"
[sflow]: rfc://3176 "RFC 3176: Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"
[goflow2]: https://github.com/NetSampler/GoFlow2
[kafka]: https://kafka.apache.org/ "Apache Kafka"
[clickhouse]: https://clickhouse.com/ "ClickHouse: OLAP DBMS"
[bench-initial]: https://github.com/akvorado/akvorado/blob/protobuf-bench-initial/inlet/flow/decoder_test.go
[new go api for protocol buffers]: https://go.dev/blog/protobuf-apiv2 "A new Go API for Protocol Buffers"
[google.golang.org/protobuf]: https://pkg.go.dev/google.golang.org/protobuf "Go support for Protocol Buffers"
[gogoprotobuf]: https://github.com/gogo/protobuf "Protocol Buffers for Go with Gadgets"
[deprecated]: https://github.com/gogo/protobuf/issues/691 "#691: GoGo Protobuf looking for new ownership"
[vtprotobuf]: https://github.com/planetscale/vtprotobuf "Protocol Buffers compiler that generates optimized marshaling & unmarshaling Go code"
[protowire.appendvarint]: https://pkg.go.dev/google.golang.org/protobuf@v1.28.1/encoding/protowire#AppendVarint
[protowire.appendtag]: https://pkg.go.dev/google.golang.org/protobuf@v1.28.1/encoding/protowire#AppendTag
[protowire.appendbytes]: https://pkg.go.dev/google.golang.org/protobuf@v1.28.1/encoding/protowire#AppendBytes
[sflow decoder]: https://github.com/akvorado/akvorado/blob/main/inlet/flow/decoder/sflow/decode.go
[helper methods]: https://github.com/akvorado/akvorado/blob/main/common/schema/protobuf.go
[go profiler]: https://go.dev/blog/pprof "Profiling Go Programs"
[conversion]: https://github.com/akvorado/akvorado/commit/e352202631a898947925337232647fdce50aa0f1
[binary.read]: https://pkg.go.dev/encoding/binary#Read
[pr141]: https://github.com/netsampler/goflow2/pull/141 "#141: decoders: replace binary.Read with a version without reflection and allocations"
[protoreflect]: https://pkg.go.dev/github.com/jhump/protoreflect
[protobufdecode]: https://github.com/akvorado/akvorado/blob/9c51b2284513526f6491a9138953e0bd00f680a8/common/schema/tests.go#L44-L117
[new data]: https://demo.akvorado.net/docs/internals#schema
[cbor]: https://cbor.io/ "RFC 8949 Concise Binary Object Representation"
[chatgpt]: https://chat.openai.com/chat
[deepl]: https://www.deepl.com/translator
