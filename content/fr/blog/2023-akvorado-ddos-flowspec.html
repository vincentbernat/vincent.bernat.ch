---
title: "DÃ©tection et suppression des DDoS avec Akvorado et Flowspec"
description: |
   Construisez un systÃ¨me de suppression des attaques DDoS Ã  partir des donnÃ©es
   recueillies par Akvorado et avec l'aide de rÃ¨gles Flowspec.
uuid: 2ebe9147-a4ca-43a0-ad4a-9df54ed53ff1
tags:
  - network-monitoring
  - network-bgp
  - project-akvorado
---

[Akvorado][] collecte des flux [sFlow][] et [IPFIX][], les stocke dans une base
de donnÃ©es [ClickHouse][] et les prÃ©sente dans une console web. Bien qu'il n'y
ait pas de dÃ©tection de DDoS intÃ©grÃ©e, il est possible d'en crÃ©er une Ã 
partir de requÃªtes pour _ClickHouse_.

# DÃ©tection des attaques DDoS

Supposons que nous voulions dÃ©tecter des attaques DDoS ciblant nos clients. Ã€
titre d'exemple, nous considÃ©rons une attaque DDoS comme une collection de flux
sur **une minute** ciblant une **adresse IP client unique**, Ã  partir d'un
**port source unique** et correspondant Ã  l'une de ces conditions :

- une bande passante moyenne de 1 Gbit/s,
- une bande passante moyenne de 200 Mbit/s lorsque le protocole est UDP,
- plus de 20 adresses IP sources et une bande passante moyenne de 100 Mbit/s, ou
- plus de 10 pays sources et une bande passante moyenne de 100 Mbit/s.

Voici la requÃªte SQL pour dÃ©tecter de telles attaques au cours des 5 derniÃ¨res
minutes :

```sql
SELECT *
FROM (
  SELECT
    toStartOfMinute(TimeReceived) AS TimeReceived,
    DstAddr,
    SrcPort,
    dictGetOrDefault('protocols', 'name', Proto, '???') AS Proto,
    SUM(((((Bytes * SamplingRate) * 8) / 1000) / 1000) / 1000) / 60 AS Gbps,
    uniq(SrcAddr) AS sources,
    uniq(SrcCountry) AS countries
  FROM flows
  WHERE TimeReceived > now() - INTERVAL 5 MINUTE
    AND DstNetRole = 'customers'
  GROUP BY
    TimeReceived,
    DstAddr,
    SrcPort,
    Proto
)
WHERE (Gbps > 1)
   OR ((Proto = 'UDP') AND (Gbps > 0.2)) 
   OR ((sources > 20) AND (Gbps > 0.1)) 
   OR ((countries > 10) AND (Gbps > 0.1))
ORDER BY
  TimeReceived DESC,
  Gbps DESC
```

Voici un exemple de sortie[^format] oÃ¹ deux de nos utilisateurs sont attaquÃ©s.
L'un d'eux subit apparemment une [attaque d'amplification NTP][NTP amplification
attack], l'autre une [attaque d'amplification DNS][DNS amplification attack] :

|        TimeReceived | DstAddr                | SrcPort | Proto |  Gbps | sources | countries |
|--------------------:|:-----------------------|--------:|:------|------:|--------:|----------:|
| 2023-02-26 17:44:00 | `::ffff:203.0.113.206` |     123 | UDP   | 0.102 |     109 |        13 |
| 2023-02-26 17:43:00 | `::ffff:203.0.113.206` |     123 | UDP   | 0.130 |     133 |        17 |
| 2023-02-26 17:43:00 | `::ffff:203.0.113.68`  |      53 | UDP   | 0.129 |     364 |        63 |
| 2023-02-26 17:43:00 | `::ffff:203.0.113.206` |     123 | UDP   | 0.113 |     129 |        21 |
| 2023-02-26 17:42:00 | `::ffff:203.0.113.206` |     123 | UDP   | 0.139 |      50 |        14 |
| 2023-02-26 17:42:00 | `::ffff:203.0.113.206` |     123 | UDP   | 0.105 |      42 |        14 |
| 2023-02-26 17:40:00 | `::ffff:203.0.113.68`  |      53 | UDP   | 0.121 |     340 |        65 |

[^format]: *ClickHouse* peut exporter les rÃ©sultats au format *Markdown* en
    ajoutant `FORMAT Markdown` Ã  la requÃªte.

# Suppression des attaques DDoS

Une fois dÃ©tectÃ©e, il existe au moins deux faÃ§ons d'arrÃªter l'attaque au niveau
du rÃ©seau :

- supprimer tout le trafic vers l'utilisateur ciblÃ© (_RTBH_)
- supprimer sÃ©lectivement les paquets correspondant aux motifs de l'attaque
  (_Flowspec_)

## Suppression du trafic avec RTBH

La mÃ©thode la plus simple consiste Ã  sacrifier l'utilisateur attaquÃ©. Bien que
cela aide l'attaquant, cela protÃ¨ge avant tout votre rÃ©seau. C'est une mÃ©thode
prise en charge par tous les routeurs. Vous pouvez Ã©galement dÃ©lÃ©guer cette
protection Ã  la plupart des fournisseurs de transit. Cela est utile si le volume
des attaques dÃ©passe la capacitÃ© de votre connexion Internet.

Cela fonctionne en annonÃ§ant avec BGP une route vers l'utilisateur attaquÃ© avec
une communautÃ© spÃ©cifique. Le routeur de bordure modifie l'adresse du prochain
routeur de ces routes vers une adresse IP spÃ©cifique configurÃ©e pour transfÃ©rer
le trafic vers l'interface Â«Â nulleÂ Â». La [RFC 7999][] dÃ©finit `65535:666` Ã 
cette fin. C'est ce qu'on appelle un trou noir dÃ©clenchÃ© Ã  distance (â€œ_remote
triggered blackhole_â€, RTBH) et expliquÃ© en dÃ©tail dans la [RFC 3882][].

Il est Ã©galement possible de bloquer la source des attaques en utilisant uRPF
dÃ©fini dans la [RFC 3704][]. C'est expliquÃ© dans la [RFC 5635][]. Cependant,
uRPF peut Ãªtre une charge importante pour les ressources de votre routeur.
Consultez "[NCS5500 uRPF: Configuration et Impact sur l'Ã©chelle][NCS5500 uRPF:
Configuration and Impact on Scale]" pour un exemple des types de restrictions
auxquelles vous devez vous attendre lorsque vous activez uRPF.

Pour annoncer les routes, nous pouvons utiliser [BIRD][]. Voici un fichier de
configuration complet pour permettre Ã  tout routeur de les collecter :

```junos hl_lines="18 24 25 30 31 32 33 34 35"
log stderr all;
router id 192.0.2.1;

protocol device {
  scan time 10;
}

protocol bgp exporter {
  ipv4 {
    import none;
    export where proto = "blackhole4";
  };
  ipv6 {
    import none;
    export where proto = "blackhole6";
  };
  local as 64666;
  neighbor range 192.0.2.0/24 external;
  multihop;
  dynamic name "exporter";
  dynamic name digits 2;
  graceful restart yes;
  graceful restart time 0;
  long lived graceful restart yes;
  long lived stale time 3600;  # keep routes for 1 hour!
}

protocol static blackhole4 {
  ipv4;
  route 203.0.113.206/32 blackhole {
    bgp_community.add((65535, 666));
  };
  route 203.0.113.68/32 blackhole {
    bgp_community.add((65535, 666));
  };
}
protocol static blackhole6 {
  ipv6;
}
```

Nous utilisons [BGP LLGR][] pour garantir que les routes sont conservÃ©es pendant
une heure, mÃªme si la connexion BGP est interrompue, notamment pendant une
maintenance.

Du cÃ´tÃ© du rÃ©cepteur, si vous disposez d'un routeur Cisco fonctionnant sous IOS
XR, vous pouvez utiliser la configuration suivante pour Ã©liminer le trafic reÃ§u
sur la session BGP. Comme la session BGP est dÃ©diÃ©e Ã  cette utilisation, la
communautÃ© `65535:666` n'est pas utilisÃ©e, mais vous pouvez aussi transfÃ©rer ces
routes Ã  vos fournisseurs de transit.

```cisco
router static
 vrf public
  address-family ipv4 unicast
   192.0.2.1/32 Null0 description "BGP blackhole"
  !
  address-family ipv6 unicast
   2001:db8::1/128 Null0 description "BGP blackhole"
  !
 !
!
route-policy blackhole_ipv4_in_public
  if destination in (0.0.0.0/0 le 31) then
    drop
  endif
  set next-hop 192.0.2.1
  done
end-policy
!
route-policy blackhole_ipv6_in_public
  if destination in (::/0 le 127) then
    drop
  endif
  set next-hop 2001:db8::1
  done
end-policy
!
router bgp 12322
 neighbor-group BLACKHOLE_IPV4_PUBLIC
  remote-as 64666
  ebgp-multihop 255
  update-source Loopback10
  address-family ipv4 unicast
   maximum-prefix 100 90
   route-policy blackhole_ipv4_in_public in
   route-policy drop out
   long-lived-graceful-restart stale-time send 86400 accept 86400
  !
  address-family ipv6 unicast
   maximum-prefix 100 90
   route-policy blackhole_ipv6_in_public in
   route-policy drop out
   long-lived-graceful-restart stale-time send 86400 accept 86400
  !
 !
 vrf public
  neighbor 192.0.2.1
   use neighbor-group BLACKHOLE_IPV4_PUBLIC
   description akvorado-1
```

Lorsque le trafic est Ã©liminÃ©, il est toujours remontÃ© par _IPFIX_ et _sFlow_.
Dans *Akvorado*, utilisez `ForwardingStatus >= 128` comme filtre pour
sÃ©lectionner celui-ci.

Bien que cette mÃ©thode soit compatible avec tous les routeurs, elle permet Ã 
l'attaque de rÃ©ussir car la cible est complÃ¨tement inaccessible. Si votre
routeur le prend en charge, *Flowspec* peut filtrer sÃ©lectivement les flux pour
**arrÃªter l'attaque sans affecter le client**.

## Suppression du trafic avec Flowspec

*Flowspec* est dÃ©fini dans la [RFC 8955][] et permet la transmission de
spÃ©cifications de flux dans des sessions BGP. Une spÃ©cification de flux est un
ensemble de critÃ¨res Ã  appliquer au trafic IP. Ceux-ci incluent le prÃ©fixe
source et destination, le protocole IP, le port source et destination et la
longueur des paquets. Chaque spÃ©cification de flux est associÃ©e Ã  une action,
encodÃ©e sous forme d'une communautÃ© Ã©tendue : limitation du trafic, marquage ou
redirection.

Pour annoncer des spÃ©cifications de flux avec *BIRD*, nous complÃ©tons notre
configuration. La communautÃ© Ã©tendue utilisÃ©e limite le trafic correspondant Ã  0
octet par seconde.

```junos
flow4 table flowtab4;
flow6 table flowtab6;

protocol bgp exporter {
  flow4 {
    import none;
    export where proto = "flowspec4";
  };
  flow6 {
    import none;
    export where proto = "flowspec6";
  };
  # [â€¦]
}

protocol static flowspec4 {
  flow4;
  route flow4 {
    dst 203.0.113.68/32;
    sport = 53;
    length >= 1476 && <= 1500;
    proto = 17;
  }{
    bgp_ext_community.add((generic, 0x80060000, 0x00000000));
  };
  route flow4 {
    dst 203.0.113.206/32;
    sport = 123;
    length = 468;
    proto = 17;
  }{
    bgp_ext_community.add((generic, 0x80060000, 0x00000000));
  };
}
protocol static flowspec6 {
  flow6;
}
```

Si vous avez un routeur ASR tournant sous IOS XR, la configuration ressemble Ã  ceci :

```cisco
vrf public
 address-family ipv4 flowspec
 address-family ipv6 flowspec
!
router bgp 12322
 address-family vpnv4 flowspec
 address-family vpnv6 flowspec
 neighbor-group FLOWSPEC_IPV4_PUBLIC
  remote-as 64666
  ebgp-multihop 255
  update-source Loopback10
  address-family ipv4 flowspec
   long-lived-graceful-restart stale-time send 86400 accept 86400
   route-policy accept in
   route-policy drop out
   maximum-prefix 100 90
   validation disable
  !
  address-family ipv6 flowspec
   long-lived-graceful-restart stale-time send 86400 accept 86400
   route-policy accept in
   route-policy drop out
   maximum-prefix 100 90
   validation disable
  !
 !
 vrf public
  address-family ipv4 flowspec
  address-family ipv6 flowspec
  neighbor 192.0.2.1
   use neighbor-group FLOWSPEC_IPV4_PUBLIC
   description akvorado-1
```

Ensuite, il convient d'activer _Flowspec_ sur toutes les interfaces :

```cisco
flowspec
 vrf public
  address-family ipv4
   local-install interface-all
  !
  address-family ipv6
   local-install interface-all
  !
 !
!
```

Comme pour la configuration Ã  base de RTBH, vous pouvez afficher les flux
Ã©liminÃ©s avec le filtre `ForwardingStatus >= 128`.

# DÃ©tection des attaques DDoS (suite)

Dans l'exemple utilisant _Flowspec_, les flux sont aussi filtrÃ©s selon la
longueur des paquets :

```junos
route flow4 {
  dst 203.0.113.68/32;
  sport = 53;
  length >= 1476 && <= 1500;
  proto = 17;
}{
  bgp_ext_community.add((generic, 0x80060000, 0x00000000));
};
```

C'est une addition importante : les requÃªtes DNS lÃ©gitimes ont une taille
infÃ©rieure Ã  cela et ne sont donc pas filtrÃ©es[^dns]. Avec _ClickHouse_, vous pouvez
obtenir les 10<sup>Ã¨me</sup> et 90<sup>Ã¨me</sup> centiles des tailles de paquets
avec `quantiles(0.1, 0.9)(Bytes/Packets)`.

[^dns]: Bien que la plupart des clients DNS rÃ©essaient avec TCP en cas d'Ã©chec,
    ce n'est pas toujours le cas : jusqu'Ã  [rÃ©cemment][recently], la
    [bibliothÃ¨que Musl][musl libc] ne le faisait pas.

Le dernier problÃ¨me que nous devons rÃ©soudre est de rendre les requÃªtes plus
rapides : elles peuvent avoir besoin de plusieurs secondes pour collecter les
donnÃ©es et sont susceptibles de consommer des ressources substantielles de votre
base de donnÃ©es *ClickHouse*. Une solution consiste Ã  crÃ©er une vue matÃ©rialisÃ©e
pour prÃ©-agrÃ©ger les rÃ©sultats :

```sql hl_lines="11"
CREATE TABLE ddos_logs (
  TimeReceived DateTime,
  DstAddr IPv6,
  Proto UInt32,
  SrcPort UInt16,
  Gbps SimpleAggregateFunction(sum, Float64),
  Mpps SimpleAggregateFunction(sum, Float64),
  sources AggregateFunction(uniqCombined(12), IPv6),
  countries AggregateFunction(uniqCombined(12), FixedString(2)),
  size AggregateFunction(quantiles(0.1, 0.9), UInt64)
) ENGINE = SummingMergeTree
PARTITION BY toStartOfHour(TimeReceived)
ORDER BY (TimeReceived, DstAddr, Proto, SrcPort)
TTL toStartOfHour(TimeReceived) + INTERVAL 6 HOUR DELETE ;

CREATE MATERIALIZED VIEW ddos_logs_view TO ddos_logs AS
  SELECT
    toStartOfMinute(TimeReceived) AS TimeReceived,
    DstAddr,
    Proto,
    SrcPort,
    sum(((((Bytes * SamplingRate) * 8) / 1000) / 1000) / 1000) / 60 AS Gbps,
    sum(((Packets * SamplingRate) / 1000) / 1000) / 60 AS Mpps,
    uniqCombinedState(12)(SrcAddr) AS sources,
    uniqCombinedState(12)(SrcCountry) AS countries,
    quantilesState(0.1, 0.9)(toUInt64(Bytes/Packets)) AS size
  FROM flows
  WHERE DstNetRole = 'customers'
  GROUP BY
    TimeReceived,
    DstAddr,
    Proto,
    SrcPort
```

La table `ddos_logs` utilise le moteur `SummingMergeTree`. Lorsque la table
reÃ§oit de nouvelles donnÃ©es, _ClickHouse_ remplace toutes les lignes ayant la
mÃªme clÃ© de tri, telle que dÃ©finie par la directive `ORDER BY`, par une seule
ligne qui contient des valeurs rÃ©sumÃ©es[^materialized] en utilisant soit la
fonction `sum()` soit la fonction d'agrÃ©gation explicitement spÃ©cifiÃ©e
(`uniqCombined` et `quantiles` dans notre exemple).

[^materialized]: La vue matÃ©rialisÃ©e agrÃ¨ge Ã©galement les donnÃ©es qu'elle a sous
    la main, Ã  la fois pour l'efficacitÃ© et pour s'assurer que nous travaillons
    avec les bons types de donnÃ©es.

Enfin, nous modifions notre requÃªte initiale avec la requÃªte suivante :

```sql
SELECT *
FROM (
  SELECT
    TimeReceived,
    DstAddr,
    dictGetOrDefault('protocols', 'name', Proto, '???') AS Proto,
    SrcPort,
    sum(Gbps) AS Gbps,
    sum(Mpps) AS Mpps,
    uniqCombinedMerge(12)(sources) AS sources,
    uniqCombinedMerge(12)(countries) AS countries,
    quantilesMerge(0.1, 0.9)(size) AS size
  FROM ddos_logs
  WHERE TimeReceived > now() - INTERVAL 60 MINUTE
  GROUP BY
    TimeReceived,
    DstAddr,
    Proto,
    SrcPort
)
WHERE (Gbps > 1)
   OR ((Proto = 'UDP') AND (Gbps > 0.2)) 
   OR ((sources > 20) AND (Gbps > 0.1)) 
   OR ((countries > 10) AND (Gbps > 0.1))
ORDER BY
  TimeReceived DESC,
  Gbps DESC
```

# Assemblage final

Pour rÃ©sumer, la construction d'un systÃ¨me de suppression des attaques DDoS
nÃ©cessite de suivre les Ã©tapes suivantes :

1. dÃ©finir un ensemble de critÃ¨res pour dÃ©tecter une attaque DDoS
2. traduire ces critÃ¨res en requÃªtes SQL
3. prÃ©-agrÃ©ger les flux dans des tables `SummingMergeTree`
4. interroger et transformer les rÃ©sultats en un fichier de configuration pour _BIRD_
5. configurer vos routeurs pour extraire les routes de _BIRD_

Un script Python comme celui qui suit permet de gÃ©rer la quatriÃ¨me Ã©tape. Pour
chaque cible attaquÃ©e, il gÃ©nÃ¨re Ã  la fois une rÃ¨gle _Flowspec_ et une route de
type Â«Â trou noirÂ Â».

```python
{% raw %}
import socket
import types
from clickhouse_driver import Client as CHClient

# InsÃ©rez ici votre requÃªte SQL
SQL_QUERY = "â€¦"

# Combien de rÃ¨gles anti-DDoS doit-on publier au plus ?
MAX_DDOS_RULES = 20

def empty_ruleset():
    ruleset = types.SimpleNamespace()
    ruleset.flowspec = types.SimpleNamespace()
    ruleset.blackhole = types.SimpleNamespace()
    ruleset.flowspec.v4 = []
    ruleset.flowspec.v6 = []
    ruleset.blackhole.v4 = []
    ruleset.blackhole.v6 = []
    return ruleset

current_ruleset = empty_ruleset()

client = CHClient(host="clickhouse.akvorado.net")
while True:
    results = client.execute(SQL_QUERY)
    seen = {}
    new_ruleset = empty_ruleset()
    for (t, addr, proto, port, gbps, mpps, sources, countries, size) in results:
        if (addr, proto, port) in seen:
            continue
        seen[(addr, proto, port)] = True

        # Flowspec
        if addr.ipv4_mapped:
            address = addr.ipv4_mapped
            rules = new_ruleset.flowspec.v4
            table = "flow4"
            mask = 32
            nh = "proto"
        else:
            address = addr
            rules = new_ruleset.flowspec.v6
            table = "flow6"
            mask = 128
            nh = "next header"
        if size[0] == size[1]:
            length = f"length = {int(size[0])}"
        else:
            length = f"length >= {int(size[0])} && <= {int(size[1])}"
        header = f"""
# Time: {t}
# Source: {address}, protocol: {proto}, port: {port}
# Gbps/Mpps: {gbps:.3}/{mpps:.3}, packet size: {int(size[0])}<=X<={int(size[1])}
# Flows: {flows}, sources: {sources}, countries: {countries}
"""
        rules.append(
                f"""{header}
route {table} {{
  dst {address}/{mask};
  sport = {port};
  {length};
  {nh} = {socket.getprotobyname(proto)};
}}{{
  bgp_ext_community.add((generic, 0x80060000, 0x00000000));
}};
"""
        )

        # Blackhole
        if addr.ipv4_mapped:
            rules = new_ruleset.blackhole.v4
        else:
            rules = new_ruleset.blackhole.v6
        rules.append(
            f"""{header}
route {address}/{mask} blackhole {{
  bgp_community.add((65535, 666));
}};
"""
        )

        new_ruleset.flowspec.v4 = list(
            set(new_ruleset.flowspec.v4[:MAX_DDOS_RULES])
        )
        new_ruleset.flowspec.v6 = list(
            set(new_ruleset.flowspec.v6[:MAX_DDOS_RULES])
        )

        # TODO: publier les changements par courriel ou chat

        current_ruleset = new_ruleset
        changes = False
        for rules, path in (
            (current_ruleset.flowspec.v4, "v4-flowspec"),
            (current_ruleset.flowspec.v6, "v6-flowspec"),
            (current_ruleset.blackhole.v4, "v4-blackhole"),
            (current_ruleset.blackhole.v6, "v6-blackhole"),
        ):
            path = os.path.join("/etc/bird/", f"{path}.conf")
            with open(f"{path}.tmp", "w") as f:
                for r in rules:
                    f.write(r)
            changes = (
                changes or not os.path.exists(path) or not samefile(path, f"{path}.tmp")
            )
            os.rename(f"{path}.tmp", path)

        if not changes:
            continue

        proc = subprocess.Popen(
            ["birdc", "configure"],
            stdin=subprocess.DEVNULL,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = proc.communicate(None)
        stdout = stdout.decode("utf-8", "replace")
        stderr = stderr.decode("utf-8", "replace")
        if proc.returncode != 0:
            logger.error(
                "{} error:\n{}\n{}".format(
                    "birdc reconfigure",
                    "\n".join(
                        [" O: {}".format(line) for line in stdout.rstrip().split("\n")]
                    ),
                    "\n".join(
                        [" E: {}".format(line) for line in stderr.rstrip().split("\n")]
                    ),
                )
            )
{% endraw %}
```

---

Jusqu'Ã  ce qu'*Akvorado* intÃ¨gre la dÃ©tection et la lutte contre les attaques
DDoS, les idÃ©es prÃ©sentÃ©es dans ce billet fournissent une base solide pour
commencer Ã  construire votre propre systÃ¨me anti-DDoS. ðŸ›¡ï¸

*[DDoS]: Distributed Denial of Service
*[ISP]: Internet Service Provider
*[TCAM]: Ternary Content-Addressable Memory
*[BGP]: Border Gateway Protocol
*[RTBH]: Remote Triggered Blackhole
*[uRPF]: Unicast Reverse Path Forwarding
*[ACLs]: Access Control Lists

[akvorado]: [[fr/blog/2022-akvorado-collecteur-flux.html]] "Akvorado : collecteur et visualisateur de flux rÃ©seau"
[ipfix]: rfc://7011 "RFC 7011: Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"
[sflow]: rfc://3176 "RFC 3176: Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of Flow Information"
[clickhouse]: https://clickhouse.com/ "ClickHouse: OLAP DBMS"
[ntp amplification attack]: https://www.cloudflare.com/learning/ddos/ntp-amplification-ddos-attack/ "NTP amplification DDoS attack"
[dns amplification attack]: https://www.cloudflare.com/learning/ddos/dns-amplification-ddos-attack/ "DNS amplification attack"
[rfc 7999]: rfc://7999 "BLACKHOLE Community"
[rfc 3882]: rfc://3882 "Configuring BGP to Block Denial-of-Service Attacks"
[rfc 3704]: rfc://3704 "Ingress Filtering for Multihomed Networks"
[rfc 5635]: rfc://5635 "Remote Triggered Black Hole Filtering with Unicast Reverse Path Forwarding (uRPF)"
[ncs5500 urpf: configuration and impact on scale]: https://xrdocs.io/ncs5500/tutorials/ncs5500-urpf/ "NCS5500 uRPF: Configuration and Impact on Scale"
[bird]: https://bird.network.cz/ "The BIRD Internet Routing Daemon"
[bgp llgr]: [[fr/blog/2018-bgp-llgr.html]] "BGP LLGR : sessions BGP fiables et rÃ©actives"
[rfc 8955]: rfc://8955 "Dissemination of Flow Specification Rules"
[xrdocs-flowspec]: https://xrdocs.io/ncs5500/tutorials/bgp-flowspec-on-ncs5500/ "BGP Flowspec on NCS5500: A few tests on scale, rate and memory usage"
[xrdocs-acls]: https://xrdocs.io/ncs5500/tutorials/bgp-flowspec-to-acl-script/ "BGP Flowspec to ACL Script"
[recently]: https://git.musl-libc.org/cgit/musl/commit/?id=51d4669fb97782f6a66606da852b5afd49a08001
[musl libc]: https://musl.libc.org/
